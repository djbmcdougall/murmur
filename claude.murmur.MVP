// PROJECT STRUCTURE
/**
 * /
 * ├── client/                  # Frontend React application
 * │   ├── public/              # Static assets
 * │   ├── src/
 * │   │   ├── api/             # API client with typed endpoints
 * │   │   ├── components/      # React components
 * │   │   ├── hooks/           # Custom React hooks
 * │   │   ├── pages/           # Page components
 * │   │   ├── store/           # Redux state management
 * │   │   ├── types/           # TypeScript type definitions
 * │   │   ├── utils/           # Utility functions
 * │   │   ├── App.tsx          # Main App component
 * │   │   ├── index.tsx        # Entry point
 * │   ├── package.json         # Frontend dependencies
 * │   ├── tsconfig.json        # TypeScript configuration
 * ├── server/                  # Backend Node.js application
 * │   ├── src/
 * │   │   ├── config/          # Configuration files
 * │   │   ├── controllers/     # Route controllers
 * │   │   ├── middleware/      # Express middleware
 * │   │   ├── models/          # Database models
 * │   │   ├── routes/          # API routes
 * │   │   ├── services/        # Business logic
 * │   │   ├── types/           # TypeScript type definitions
 * │   │   ├── utils/           # Utility functions
 * │   │   ├── app.ts           # Express app setup
 * │   │   ├── server.ts        # Server entry point
 * │   ├── package.json         # Backend dependencies
 * │   ├── tsconfig.json        # TypeScript configuration
 * ├── docker/                  # Docker configuration
 * │   ├── docker-compose.yml   # Multi-container setup
 * │   ├── Dockerfile.client    # Frontend container
 * │   ├── Dockerfile.server    # Backend container
 * ├── .github/                 # GitHub workflows for CI/CD
 * ├── README.md                # Project documentation
 * ├── LICENSE                  # License information
 */

// client/src/types/index.ts
export interface User {
  id: string;
  name: string;
  bio: string | null;
  profilePic: string | null;
  listenersCount: number;
  listeningCount: number;
  createdAt: string;
  updatedAt: string;
}

export interface Recommendation {
  id: string;
  userId: string;
  text: string;
  audioUrl: string;
  category: string;
  sentiment: SentimentAnalysis;
  createdAt: string;
  user?: User;
}

export interface SentimentAnalysis {
  score: number;
  keywords: Array<{
    text: string;
    sentiment: number;
  }>;
  overall: 'positive' | 'negative' | 'neutral';
}

export interface AudioRecording {
  blob: Blob;
  url: string;
  duration: number;
}

export interface ApiError {
  message: string;
  status?: number;
  errors?: Record<string, string[]>;
}

export type Category = 
  | 'Food' 
  | 'Travel' 
  | 'Shopping' 
  | 'Experiences' 
  | 'Books' 
  | 'Movies' 
  | 'Music' 
  | 'Technology' 
  | 'Health & Wellness';

export type VoiceTone = 'Excited' | 'Calm' | 'Serious';

// client/src/api/client.ts
import axios, { AxiosError, AxiosRequestConfig } from 'axios';
import { ApiError } from '../types';

const API_URL = process.env.REACT_APP_API_URL || 'https://murmurs.app/api';

const apiClient = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 10000,
});

// Request interceptor for adding auth token
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('authToken');
    if (token && config.headers) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor for error handling
apiClient.interceptors.response.use(
  (response) => response,
  (error: AxiosError) => {
    const apiError: ApiError = {
      message: 'An unknown error occurred',
      status: error.response?.status,
    };

    if (error.response) {
      // The request was made and the server responded with a status code
      // that falls out of the range of 2xx
      apiError.message = error.response.data?.message || 'Server error';
      apiError.errors = error.response.data?.errors;
      
      // Handle authentication errors
      if (error.response.status === 401) {
        // Clear token and redirect to login
        localStorage.removeItem('authToken');
        window.location.href = '/login';
      }
    } else if (error.request) {
      // The request was made but no response was received
      apiError.message = 'No response from server. Please check your connection.';
    } else {
      // Something happened in setting up the request
      apiError.message = error.message;
    }

    return Promise.reject(apiError);
  }
);

export const get = async <T>(url: string, config?: AxiosRequestConfig): Promise<T> => {
  const response = await apiClient.get<T>(url, config);
  return response.data;
};

export const post = async <T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> => {
  const response = await apiClient.post<T>(url, data, config);
  return response.data;
};

export const put = async <T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> => {
  const response = await apiClient.put<T>(url, data, config);
  return response.data;
};

export const del = async <T>(url: string, config?: AxiosRequestConfig): Promise<T> => {
  const response = await apiClient.delete<T>(url, config);
  return response.data;
};

export default apiClient;

// client/src/api/recommendations.ts
import { get, post } from './client';
import { Recommendation } from '../types';

export const fetchRecommendations = async (
  category?: string, 
  searchQuery?: string, 
  page = 1, 
  limit = 10
): Promise<{ recommendations: Recommendation[], total: number }> => {
  return get<{ recommendations: Recommendation[], total: number }>('/recommendations', {
    params: { category, q: searchQuery, page, limit }
  });
};

export const fetchRecommendation = async (id: string): Promise<Recommendation> => {
  return get<Recommendation>(`/recommendations/${id}`);
};

export const createRecommendation = async (
  data: { 
    text: string; 
    category: string; 
    tone: string;
    audioBlob?: Blob;
  }
): Promise<Recommendation> => {
  const formData = new FormData();
  formData.append('text', data.text);
  formData.append('category', data.category);
  formData.append('tone', data.tone);
  
  if (data.audioBlob) {
    formData.append('audio', data.audioBlob, 'recording.webm');
  }

  return post<Recommendation>('/recommendations', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  });
};

// client/src/api/users.ts
import { get, post } from './client';
import { User, Recommendation } from '../types';

export const fetchUser = async (id: string): Promise<User> => {
  return get<User>(`/users/${id}`);
};

export const fetchUserRecommendations = async (
  userId: string,
  page = 1,
  limit = 10
): Promise<{ recommendations: Recommendation[], total: number }> => {
  return get<{ recommendations: Recommendation[], total: number }>(`/users/${userId}/recommendations`, {
    params: { page, limit }
  });
};

export const listenToUser = async (userId: string): Promise<{ message: string }> => {
  return post<{ message: string }>(`/users/${userId}/listen`);
};

export const muteUser = async (userId: string): Promise<{ message: string }> => {
  return post<{ message: string }>(`/users/${userId}/mute`);
};

export const updateProfile = async (
  data: {
    name?: string;
    bio?: string;
    profilePic?: File;
  }
): Promise<User> => {
  const formData = new FormData();
  if (data.name) formData.append('name', data.name);
  if (data.bio) formData.append('bio', data.bio);
  if (data.profilePic) formData.append('profilePic', data.profilePic);

  return post<User>('/users/profile', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  });
};

// client/src/api/auth.ts
import { post } from './client';

interface AuthResponse {
  token: string;
  user: {
    id: string;
    name: string;
    email: string;
  };
}

export const login = async (
  email: string,
  password: string
): Promise<AuthResponse> => {
  const response = await post<AuthResponse>('/auth/login', { email, password });
  // Store token in localStorage
  localStorage.setItem('authToken', response.token);
  return response;
};

export const register = async (
  name: string,
  email: string,
  password: string
): Promise<AuthResponse> => {
  const response = await post<AuthResponse>('/auth/register', { name, email, password });
  // Store token in localStorage
  localStorage.setItem('authToken', response.token);
  return response;
};

export const logout = (): void => {
  localStorage.removeItem('authToken');
};

// client/src/hooks/useAudioRecorder.ts
import { useState, useCallback, useRef, useEffect } from 'react';
import { AudioRecording } from '../types';

interface AudioRecorderHook {
  recording: boolean;
  audioURL: string | null;
  audioDuration: number;
  startRecording: () => Promise<void>;
  stopRecording: () => Promise<AudioRecording | null>;
  resetRecording: () => void;
  error: string | null;
}

export const useAudioRecorder = (maxDurationMs = 30000): AudioRecorderHook => {
  const [recording, setRecording] = useState<boolean>(false);
  const [audioURL, setAudioURL] = useState<string | null>(null);
  const [audioDuration, setAudioDuration] = useState<number>(0);
  const [error, setError] = useState<string | null>(null);
  
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const streamRef = useRef<MediaStream | null>(null);
  const chunksRef = useRef<BlobPart[]>([]);
  const startTimeRef = useRef<number>(0);
  const durationTimerRef = useRef<number | null>(null);
  const maxDurationTimerRef = useRef<number | null>(null);
  
  // Clean up function to stop all recording processes
  const cleanup = useCallback(() => {
    if (durationTimerRef.current) {
      window.clearInterval(durationTimerRef.current);
      durationTimerRef.current = null;
    }
    
    if (maxDurationTimerRef.current) {
      window.clearTimeout(maxDurationTimerRef.current);
      maxDurationTimerRef.current = null;
    }
    
    if (mediaRecorderRef.current && recording) {
      mediaRecorderRef.current.stop();
    }
    
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop());
      streamRef.current = null;
    }
    
    setRecording(false);
  }, [recording]);
  
  // Ensure cleanup on component unmount
  useEffect(() => {
    return () => {
      cleanup();
      
      // Also clean up any object URLs to prevent memory leaks
      if (audioURL) {
        URL.revokeObjectURL(audioURL);
      }
    };
  }, [cleanup, audioURL]);
  
  const startRecording = useCallback(async () => {
    try {
      // Reset any previous recordings
      resetRecording();
      
      // Request microphone access
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      streamRef.current = stream;
      
      // Set up MediaRecorder with the stream
      const mediaRecorder = new MediaRecorder(stream);
      mediaRecorderRef.current = mediaRecorder;
      
      // Set up event handlers
      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          chunksRef.current.push(event.data);
        }
      };
      
      // Start recording
      chunksRef.current = [];
      mediaRecorder.start(100); // Collect data every 100ms
      startTimeRef.current = Date.now();
      setRecording(true);
      
      // Set up timer for tracking duration
      durationTimerRef.current = window.setInterval(() => {
        const currentDuration = Date.now() - startTimeRef.current;
        setAudioDuration(currentDuration);
      }, 100);
      
      // Set up timer for maximum duration
      maxDurationTimerRef.current = window.setTimeout(() => {
        if (recording) {
          stopRecording();
        }
      }, maxDurationMs);
      
    } catch (err) {
      console.error('Error starting recording:', err);
      setError('Could not access the microphone. Please ensure it is connected and you have given permission.');
    }
  }, [maxDurationMs, recording, stopRecording]);
  
  const stopRecording = useCallback(async (): Promise<AudioRecording | null> => {
    if (!mediaRecorderRef.current || !recording) {
      return null;
    }
    
    return new Promise((resolve) => {
      if (mediaRecorderRef.current) {
        mediaRecorderRef.current.onstop = () => {
          const blob = new Blob(chunksRef.current, { type: 'audio/webm' });
          const url = URL.createObjectURL(blob);
          setAudioURL(url);
          const finalDuration = Date.now() - startTimeRef.current;
          setAudioDuration(finalDuration);
          
          // Clean up timers and streams
          if (durationTimerRef.current) {
            window.clearInterval(durationTimerRef.current);
            durationTimerRef.current = null;
          }
          
          if (maxDurationTimerRef.current) {
            window.clearTimeout(maxDurationTimerRef.current);
            maxDurationTimerRef.current = null;
          }
          
          if (streamRef.current) {
            streamRef.current.getTracks().forEach(track => track.stop());
            streamRef.current = null;
          }
          
          setRecording(false);
          
          resolve({
            blob,
            url,
            duration: finalDuration
          });
        };
        
        mediaRecorderRef.current.stop();
      } else {
        resolve(null);
      }
    });
  }, [recording]);
  
  const resetRecording = useCallback(() => {
    cleanup();
    
    if (audioURL) {
      URL.revokeObjectURL(audioURL);
    }
    
    setAudioURL(null);
    setAudioDuration(0);
    setError(null);
    chunksRef.current = [];
  }, [cleanup, audioURL]);
  
  return {
    recording,
    audioURL,
    audioDuration,
    startRecording,
    stopRecording,
    resetRecording,
    error
  };
};

// client/src/hooks/usePagination.ts
import { useState, useCallback } from 'react';

interface PaginationHook<T> {
  items: T[];
  loading: boolean;
  error: string | null;
  page: number;
  totalPages: number;
  hasMore: boolean;
  fetchPage: (newPage?: number) => Promise<void>;
  fetchNextPage: () => Promise<void>;
}

export function usePagination<T>(
  fetchFunction: (page: number, limit: number) => Promise<{ items: T[], total: number }>,
  limit = 10
): PaginationHook<T> {
  const [items, setItems] = useState<T[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [page, setPage] = useState(1);
  const [total, setTotal] = useState(0);

  const fetchPage = useCallback(async (newPage?: number) => {
    const pageToFetch = newPage !== undefined ? newPage : page;
    
    try {
      setLoading(true);
      setError(null);
      
      const result = await fetchFunction(pageToFetch, limit);
      
      setItems(result.items);
      setTotal(result.total);
      setPage(pageToFetch);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred while fetching data');
    } finally {
      setLoading(false);
    }
  }, [fetchFunction, limit, page]);

  const fetchNextPage = useCallback(async () => {
    if (page < Math.ceil(total / limit)) {
      await fetchPage(page + 1);
    }
  }, [fetchPage, page, total, limit]);

  const totalPages = Math.ceil(total / limit);
  const hasMore = page < totalPages;

  return {
    items,
    loading,
    error,
    page,
    totalPages,
    hasMore,
    fetchPage,
    fetchNextPage
  };
}

// client/src/App.tsx
import React, { useEffect, useState } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { Provider } from 'react-redux';
import { Toaster } from 'react-hot-toast';

import store from './store';
import HomePage from './pages/HomePage';
import RecordPage from './pages/RecordPage';
import ProfilePage from './pages/ProfilePage';
import LoginPage from './pages/LoginPage';
import RegisterPage from './pages/RegisterPage';
import RecommendationPage from './pages/RecommendationPage';
import NotFoundPage from './pages/NotFoundPage';
import MainLayout from './components/layout/MainLayout';
import LoadingScreen from './components/common/LoadingScreen';
import ProtectedRoute from './components/auth/ProtectedRoute';

import './App.css';

function App() {
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Simulate loading app resources
    const timer = setTimeout(() => {
      setIsLoading(false);
    }, 1500);

    return () => clearTimeout(timer);
  }, []);

  if (isLoading) {
    return <LoadingScreen />;
  }

  return (
    <Provider store={store}>
      <Router>
        <Toaster position="top-right" />
        <Routes>
          <Route path="/login" element={<LoginPage />} />
          <Route path="/register" element={<RegisterPage />} />
          
          <Route path="/" element={<MainLayout />}>
            <Route index element={<HomePage />} />
            <Route path="recommendations/:id" element={<RecommendationPage />} />
            <Route path="profile/:id" element={<ProfilePage />} />
            
            <Route path="record" element={
              <ProtectedRoute>
                <RecordPage />
              </ProtectedRoute>
            } />
          </Route>
          
          <Route path="/404" element={<NotFoundPage />} />
          <Route path="*" element={<Navigate to="/404" replace />} />
        </Routes>
      </Router>
    </Provider>
  );
}

export default App;

// client/src/components/common/AudioPlayer.tsx
import React, { useState, useEffect, useRef } from 'react';
import WaveSurfer from 'wavesurfer.js';

interface AudioPlayerProps {
  audioUrl: string;
  waveColor?: string;
  progressColor?: string;
  height?: number;
  barWidth?: number;
  barGap?: number;
  showControls?: boolean;
  className?: string;
}

const AudioPlayer: React.FC<AudioPlayerProps> = ({
  audioUrl,
  waveColor = '#ddd',
  progressColor = '#6366f1',
  height = 50,
  barWidth = 2,
  barGap = 1,
  showControls = true,
  className = '',
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const wavesurferRef = useRef<WaveSurfer | null>(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [duration, setDuration] = useState(0);
  const [currentTime, setCurrentTime] = useState(0);
  const [error, setError] = useState<string | null>(null);

  // Initialize wavesurfer
  useEffect(() => {
    if (!containerRef.current) return;

    setIsLoading(true);
    setError(null);

    try {
      const wavesurfer = WaveSurfer.create({
        container: containerRef.current,
        waveColor,
        progressColor,
        height,
        barWidth,
        barGap,
        responsive: true,
        cursorWidth: 0,
        normalize: true,
      });

      wavesurfer.on('ready', () => {
        wavesurferRef.current = wavesurfer;
        setIsLoading(false);
        setDuration(wavesurfer.getDuration());
      });

      wavesurfer.on('audioprocess', () => {
        if (wavesurfer) {
          setCurrentTime(wavesurfer.getCurrentTime());
        }
      });

      wavesurfer.on('play', () => setIsPlaying(true));
      wavesurfer.on('pause', () => setIsPlaying(false));
      wavesurfer.on('finish', () => setIsPlaying(false));

      wavesurfer.on('error', (err) => {
        console.error('WaveSurfer error:', err);
        setError('Could not load audio file');
        setIsLoading(false);
      });

      wavesurfer.load(audioUrl);

      return () => {
        wavesurfer.destroy();
      };
    } catch (err) {
      console.error('Error initializing WaveSurfer:', err);
      setError('Could not initialize audio player');
      setIsLoading(false);
    }
  }, [audioUrl, waveColor, progressColor, height, barWidth, barGap]);

  const togglePlayPause = () => {
    if (!wavesurferRef.current) return;

    if (isPlaying) {
      wavesurferRef.current.pause();
    } else {
      wavesurferRef.current.play();
    }
  };

  const formatTime = (timeInSeconds: number): string => {
    const minutes = Math.floor(timeInSeconds / 60);
    const seconds = Math.floor(timeInSeconds % 60);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  return (
    <div className={`audio-player ${className}`}>
      {isLoading && <div className="audio-loading">Loading audio...</div>}
      {error && <div className="audio-error">{error}</div>}

      <div ref={containerRef} className="waveform-container"></div>

      {showControls && (
        <div className="audio-controls">
          <button
            onClick={togglePlayPause}
            disabled={isLoading || !!error}
            aria-label={isPlaying ? 'Pause' : 'Play'}
            className="play-button"
          >
            {isPlaying ? '❚❚' : '▶'}
          </button>

          <div className="time-display">
            <span className="current-time">{formatTime(currentTime)}</span>
            <span className="duration"> / {formatTime(duration)}</span>
          </div>
        </div>
      )}
    </div>
  );
};

export default AudioPlayer;

// client/src/components/recommendations/RecommendationCard.tsx
import React from 'react';
import { Link } from 'react-router-dom';
import { Recommendation } from '../../types';
import AudioPlayer from '../common/AudioPlayer';

interface RecommendationCardProps {
  recommendation: Recommendation;
  onShare: (id: string) => void;
  onReaction: (id: string, reaction: 'like' | 'dislike') => void;
}

const RecommendationCard: React.FC<RecommendationCardProps> = ({
  recommendation,
  onShare,
  onReaction,
}) => {
  // Safely highlight sentiment keywords in text
  const renderHighlightedText = () => {
    if (!recommendation.sentiment?.keywords?.length) {
      return <p className="recommendation-text">{recommendation.text}</p>;
    }

    // Sort keywords by their position in the text to avoid overlap issues
    const sortedKeywords = [...recommendation.sentiment.keywords].sort((a, b) => {
      return recommendation.text.indexOf(a.text) - recommendation.text.indexOf(b.text);
    });

    let lastIndex = 0;
    const result = [];
    
    // Process each keyword
    for (const keyword of sortedKeywords) {
      const keywordIndex = recommendation.text.indexOf(keyword.text, lastIndex);
      
      // If keyword not found after last position, skip it
      if (keywordIndex === -1) continue;
      
      // Add text before keyword
      if (keywordIndex > lastIndex) {
        result.push(
          <React.Fragment key={`text-${lastIndex}`}>
            {recommendation.text.substring(lastIndex, keywordIndex)}
          </React.Fragment>
        );
      }
      
      // Add highlighted keyword
      const sentimentClass = keyword.sentiment > 0 
        ? 'positive-sentiment' 
        : keyword.sentiment < 0 
          ? 'negative-sentiment' 
          : 'neutral-sentiment';
          
      result.push(
        <span key={`keyword-${keywordIndex}`} className={sentimentClass}>
          {keyword.text}
        </span>
      );
      
      lastIndex = keywordIndex + keyword.text.length;
    }
    
    // Add any remaining text
    if (lastIndex < recommendation.text.length) {
      result.push(
        <React.Fragment key={`text-${lastIndex}`}>
          {recommendation.text.substring(lastIndex)}
        </React.Fragment>
      );
    }
    
    return <p className="recommendation-text">{result}</p>;
  };

  return (
    <div className="recommendation-card">
      <div className="recommendation-header">
        <Link to={`/profile/${recommendation.userId}`} className="user-info">
          <img 
            src={recommendation.user?.profilePic || '/assets/default-avatar.png'} 
            alt={recommendation.user?.name || 'User'} 
            className="user-avatar"
          />
          <div className="user-details">
            <h3 className="user-name">{recommendation.user?.name || 'Anonymous User'}</h3>
            <span className="recommendation-time">
              {new Date(recommendation.createdAt).toLocaleDateString()}
            </span>
          </div>
        </Link>
        <div className="recommendation-category">
          <span className="category-tag">{recommendation.category}</span>
        </div>
      </div>
      
      <div className="recommendation-content">
        {renderHighlightedText()}
        
        <div className="audio-section">
          <AudioPlayer 
            audioUrl={recommendation.audioUrl} 
            waveColor="#d1d5db"
            progressColor="#6366f1"
          />
        </div>
      </div>
      
      <div className="recommendation-actions">
        <div className="reaction-buttons">
          <button 
            className="reaction-button like-button" 
            onClick={() => onReaction(recommendation.id, 'like')}
            aria-label="Like"
          >
            <span className="reaction-icon">👍</span>
          </button>
          <button 
            className="reaction-button dislike-button" 
            onClick={() => onReaction(recommendation.id, 'dislike')}
            aria-label="Dislike"
          >
            <span className="reaction-icon">👎</span>
          </button>
        </div>
        
        <button 
          className="share-button" 
          onClick={() => onShare(recommendation.id)}
          aria-label="Share"
        >
          <span className="share-icon">🔗</span>
          <span className="share-text">Share</span>
        </button>
        
        <Link 
          to={`/recommendations/${recommendation.id}`} 
          className="view-button"
          aria-label="View details"
        >
          View details
        </Link>
      </div>
    </div>
  );
};

export default RecommendationCard;

// client/src/components/record/VoiceRecorder.tsx
import React, { useState, useEffect } from 'react';
import { useAudioRecorder } from '../../hooks/useAudioRecorder';
import { Category, VoiceTone, AudioRecording } from '../../types';
import toast from 'react-hot-toast';

interface VoiceRecorderProps {
  onRecordingComplete: (recording: AudioRecording) => void;
  maxDuration?: number; // in milliseconds
}

const VoiceRecorder: React.FC<VoiceRecorderProps> = ({
  onRecordingComplete,
  maxDuration = 30000, // Default 30 seconds
}) => {
  const {
    recording,
    audioURL,
    audioDuration,
    startRecording,
    stopRecording,
    resetRecording,
    error,
  } = useAudioRecorder(maxDuration);

  const [progress, setProgress] = useState(0);
  const [isHolding, setIsHolding] = useState(false);

  // Update progress bar based on recording duration
  useEffect

// client/src/components/record/VoiceRecorder.tsx
import React, { useState, useEffect } from 'react';
import { useAudioRecorder } from '../../hooks/useAudioRecorder';
import { Category, VoiceTone, AudioRecording } from '../../types';
import toast from 'react-hot-toast';

interface VoiceRecorderProps {
  onRecordingComplete: (recording: AudioRecording) => void;
  maxDuration?: number; // in milliseconds
}

const VoiceRecorder: React.FC<VoiceRecorderProps> = ({
  onRecordingComplete,
  maxDuration = 30000, // Default 30 seconds
}) => {
  const {
    recording,
    audioURL,
    audioDuration,
    startRecording,
    stopRecording,
    resetRecording,
    error,
  } = useAudioRecorder(maxDuration);

  const [progress, setProgress] = useState(0);
  const [isHolding, setIsHolding] = useState(false);

  // Update progress bar based on recording duration
  useEffect(() => {
    if (recording) {
      setProgress(Math.min((audioDuration / maxDuration) * 100, 100));
    }
  }, [audioDuration, maxDuration, recording]);

  // Handle errors from the audio recorder
  useEffect(() => {
    if (error) {
      toast.error(error);
    }
  }, [error]);

  const handleStartRecording = async () => {
    try {
      setIsHolding(true);
      await startRecording();
    } catch (err) {
      console.error('Failed to start recording:', err);
      toast.error('Could not start recording. Please check your microphone permissions.');
    }
  };

  const handleStopRecording = async () => {
    try {
      setIsHolding(false);
      const recording = await stopRecording();
      if (recording) {
        onRecordingComplete(recording);
      }
    } catch (err) {
      console.error('Failed to stop recording:', err);
      toast.error('An error occurred while saving your recording.');
    }
  };

  const handleReset = () => {
    resetRecording();
    setProgress(0);
  };

  const formatDuration = (ms: number): string => {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
  };

  return (
    <div className="voice-recorder">
      <div className="recorder-status">
        <div className="status-indicator">
          {recording && <span className="recording-pulse"></span>}
          <span className="status-text">
            {recording ? 'Recording...' : audioURL ? 'Recording complete' : 'Ready to record'}
          </span>
        </div>
        
        <div className="duration-display">
          {formatDuration(audioDuration)} / {formatDuration(maxDuration)}
        </div>
      </div>

      <div className="progress-bar-container">
        <div 
          className="progress-bar" 
          style={{ width: `${progress}%` }}
        ></div>
      </div>

      <div className="recorder-controls">
        {!audioURL ? (
          <button
            className={`record-button ${recording ? 'recording' : ''}`}
            onMouseDown={handleStartRecording}
            onMouseUp={handleStopRecording}
            onTouchStart={handleStartRecording}
            onTouchEnd={handleStopRecording}
            disabled={error !== null}
          >
            {recording ? 'Release to stop' : 'Hold to record'}
          </button>
        ) : (
          <div className="playback-controls">
            <audio src={audioURL} controls className="audio-playback"></audio>
            <button 
              className="reset-button"
              onClick={handleReset}
              aria-label="Reset recording"
            >
              Reset
            </button>
          </div>
        )}
      </div>

      {recording && (
        <p className="recording-tip">
          Speak clearly into your microphone. Recording will automatically stop after {maxDuration / 1000} seconds.
        </p>
      )}
    </div>
  );
};

export default VoiceRecorder;
// client/src/components/record/RecommendationForm.tsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Category, VoiceTone, AudioRecording } from '../../types';
import { createRecommendation } from '../../api/recommendations';
import VoiceRecorder from './VoiceRecorder';
import toast from 'react-hot-toast';

const CATEGORIES: Category[] = [
  'Food', 
  'Travel', 
  'Shopping', 
  'Experiences', 
  'Books', 
  'Movies', 
  'Music', 
  'Technology', 
  'Health & Wellness'
];

const VOICE_TONES: VoiceTone[] = ['Excited', 'Calm', 'Serious'];

const RecommendationForm: React.FC = () => {
  const navigate = useNavigate();
  const [text, setText] = useState('');
  const [category, setCategory] = useState<Category>('Experiences');
  const [tone, setTone] = useState<VoiceTone>('Excited');
  const [recording, setRecording] = useState<AudioRecording | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [step, setStep] = useState<'record' | 'details'>('record');
  
  const handleRecordingComplete = (newRecording: AudioRecording) => {
    setRecording(newRecording);
    setStep('details');
  };
  
  const handleTextChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setText(e.target.value);
  };
  
  const handleCategoryChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setCategory(e.target.value as Category);
  };
  
  const handleToneChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setTone(e.target.value as VoiceTone);
  };
  
  const handleGoBack = () => {
    setStep('record');
  };
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!recording) {
      toast.error('Please record audio before submitting');
      return;
    }
    
    if (!text.trim()) {
      toast.error('Please add a text description');
      return;
    }
    
    try {
      setIsSubmitting(true);
      
      const recommendationData = {
        text,
        category,
        tone,
        audioBlob: recording.blob
      };
      
      const result = await createRecommendation(recommendationData);
      
      toast.success('Recommendation published successfully!');
      navigate(`/recommendations/${result.id}`);
    } catch (error) {
      console.error('Error submitting recommendation:', error);
      toast.error('Failed to publish recommendation. Please try again.');
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <div className="recommendation-form">
      <h2 className="form-title">
        {step === 'record' ? 'Record Your Recommendation' : 'Finalize Your Recommendation'}
      </h2>
      
      {step === 'record' ? (
        <div className="recording-step">
          <p className="recording-instructions">
            Hold the record button and share your recommendation with the world.
            Try to be clear and concise, focusing on what you loved (or didn't).
          </p>
          
          <VoiceRecorder 
            onRecordingComplete={handleRecordingComplete}
            maxDuration={60000} // 1 minute max
          />
        </div>
      ) : (
        <form onSubmit={handleSubmit} className="details-form">
          <div className="form-group">
            <label htmlFor="recommendation-text">What's your recommendation?</label>
            <textarea
              id="recommendation-text"
              value={text}
              onChange={handleTextChange}
              placeholder="Describe what you're recommending and why..."
              rows={4}
              required
              className="text-input"
            />
          </div>
          
          <div className="form-group">
            <label htmlFor="category-select">Category</label>
            <select
              id="category-select"
              value={category}
              onChange={handleCategoryChange}
              className="category-select"
              required
            >
              {CATEGORIES.map((cat) => (
                <option key={cat} value={cat}>
                  {cat}
                </option>
              ))}
            </select>
          </div>
          
          <div className="form-group">
            <label htmlFor="tone-select">Voice Tone</label>
            <select
              id="tone-select"
              value={tone}
              onChange={handleToneChange}
              className="tone-select"
              required
            >
              {VOICE_TONES.map((t) => (
                <option key={t} value={t}>
                  {t}
                </option>
              ))}
            </select>
          </div>
          
          {recording && (
            <div className="recording-preview">
              <h3>Your Recording</h3>
              <audio src={recording.url} controls className="audio-preview" />
              <p className="recording-duration">
                Duration: {Math.round(recording.duration / 1000)} seconds
              </p>
            </div>
          )}
          
          <div className="form-actions">
            <button
              type="button"
              onClick={handleGoBack}
              className="back-button"
              disabled={isSubmitting}
            >
              Re-record
            </button>
            
            <button
              type="submit"
              className="submit-button"
              disabled={isSubmitting || !recording || !text.trim()}
            >
              {isSubmitting ? 'Publishing...' : 'Publish Recommendation'}
            </button>
          </div>
        </form>
      )}
    </div>
  );
};

export default RecommendationForm;

// client/src/pages/RecordPage.tsx
import React from 'react';
import { Helmet } from 'react-helmet';
import RecommendationForm from '../components/record/RecommendationForm';

const RecordPage: React.FC = () => {
  return (
    <div className="record-page">
      <Helmet>
        <title>Create a Recommendation | Murmur</title>
        <meta name="description" content="Share your voice recommendation with the world" />
      </Helmet>
      
      <div className="page-header">
        <h1>Share Your Recommendation</h1>
        <p className="page-description">
          Record your voice and share your honest opinion about products, places, or experiences.
        </p>
      </div>
      
      <div className="content-container">
        <RecommendationForm />
        
        <div className="recording-tips">
          <h3>Tips for a Great Recommendation</h3>
          <ul>
            <li>
              <strong>Be specific:</strong> Share details about what you're recommending
            </li>
            <li>
              <strong>Be authentic:</strong> Your honest opinion matters most
            </li>
            <li>
              <strong>Be concise:</strong> Keep your recommendation under 60 seconds
            </li>
            <li>
              <strong>Good audio:</strong> Find a quiet space to record
            </li>
          </ul>
        </div>
      </div>
    </div>
  );
};

export default RecordPage;

// client/src/components/recommendations/RecommendationFeed.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { Recommendation, Category } from '../../types';
import { fetchRecommendations } from '../../api/recommendations';
import RecommendationCard from './RecommendationCard';
import toast from 'react-hot-toast';

interface RecommendationFeedProps {
  initialCategory?: Category | null;
}

const RecommendationFeed: React.FC<RecommendationFeedProps> = ({ 
  initialCategory = null 
}) => {
  const [recommendations, setRecommendations] = useState<Recommendation[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedCategory, setSelectedCategory] = useState<Category | null>(initialCategory);
  const [searchQuery, setSearchQuery] = useState('');
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const [totalCount, setTotalCount] = useState(0);

  const CATEGORIES: Category[] = [
    'Food', 
    'Travel', 
    'Shopping', 
    'Experiences', 
    'Books', 
    'Movies', 
    'Music', 
    'Technology', 
    'Health & Wellness'
  ];

  // Fetch recommendations based on current filters
  const loadRecommendations = useCallback(async (reset = false) => {
    try {
      setLoading(true);
      setError(null);
      
      const currentPage = reset ? 1 : page;
      const result = await fetchRecommendations(
        selectedCategory || undefined,
        searchQuery || undefined,
        currentPage,
        10 // limit per page
      );
      
      if (reset) {
        setRecommendations(result.recommendations);
      } else {
        setRecommendations(prev => [...prev, ...result.recommendations]);
      }
      
      setTotalCount(result.total);
      setHasMore(result.recommendations.length === 10);
      
      if (reset) {
        setPage(1);
      } else {
        setPage(currentPage + 1);
      }
    } catch (err) {
      console.error('Error fetching recommendations:', err);
      setError('Failed to load recommendations. Please try again.');
    } finally {
      setLoading(false);
    }
  }, [selectedCategory, searchQuery, page]);

  // Initial load
  useEffect(() => {
    loadRecommendations(true);
  }, [selectedCategory, searchQuery]);

  // Handle category filter change
  const handleCategoryChange = (category: Category | null) => {
    if (category === selectedCategory) {
      setSelectedCategory(null);
    } else {
      setSelectedCategory(category);
    }
  };

  // Handle search input
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchQuery(e.target.value);
  };

  // Handle search form submission
  const handleSearchSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    loadRecommendations(true);
  };

  // Load more recommendations
  const handleLoadMore = () => {
    if (!loading && hasMore) {
      loadRecommendations();
    }
  };

  // Handle sharing a recommendation
  const handleShare = (id: string) => {
    const shareUrl = `${window.location.origin}/recommendations/${id}`;
    
    if (navigator.share) {
      navigator.share({
        title: 'Check out this recommendation on Murmur!',
        url: shareUrl
      }).catch(err => {
        console.error('Error sharing:', err);
      });
    } else {
      // Fallback to clipboard copy
      navigator.clipboard.writeText(shareUrl).then(() => {
        toast.success('Link copied to clipboard!');
      }).catch(err => {
        console.error('Error copying to clipboard:', err);
        toast.error('Failed to copy link. Please try again.');
      });
    }
  };

  // Handle reactions (like/dislike)
  const handleReaction = (id: string, reaction: 'like' | 'dislike') => {
    // This would typically call an API endpoint to record the reaction
    // For the MVP, we'll just show a toast
    toast.success(`You ${reaction}d this recommendation!`);
  };

  return (
    <div className="recommendation-feed">
      <div className="feed-filters">
        <div className="category-filters">
          {CATEGORIES.map(category => (
            <button
              key={category}
              className={`category-filter ${selectedCategory === category ? 'active' : ''}`}
              onClick={() => handleCategoryChange(category)}
            >
              {category}
            </button>
          ))}
          {selectedCategory && (
            <button 
              className="clear-filter"
              onClick={() => setSelectedCategory(null)}
            >
              Clear filter
            </button>
          )}
        </div>
        
        <form onSubmit={handleSearchSubmit} className="search-form">
          <input
            type="text"
            value={searchQuery}
            onChange={handleSearchChange}
            placeholder="Search recommendations..."
            className="search-input"
          />
          <button type="submit" className="search-button">
            Search
          </button>
        </form>
      </div>
      
      {loading && page === 1 && (
        <div className="loading-state">
          <div className="spinner"></div>
          <p>Loading recommendations...</p>
        </div>
      )}
      
      {error && (
        <div className="error-state">
          <p>{error}</p>
          <button onClick={() => loadRecommendations(true)}>Retry</button>
        </div>
      )}
      
      {!loading && !error && recommendations.length === 0 && (
        <div className="empty-state">
          <h3>No recommendations found</h3>
          <p>
            {selectedCategory || searchQuery
              ? 'Try adjusting your filters or search query'
              : 'Be the first to share a recommendation!'}
          </p>
        </div>
      )}
      
      <div className="recommendations-list">
        {recommendations.map(recommendation => (
          <RecommendationCard
            key={recommendation.id}
            recommendation={recommendation}
            onShare={handleShare}
            onReaction={handleReaction}
          />
        ))}
      </div>
      
      {!loading && hasMore && (
        <div className="load-more">
          <button 
            onClick={handleLoadMore}
            className="load-more-button"
          >
            Load More
          </button>
        </div>
      )}
      
      {loading && page > 1 && (
        <div className="loading-more">
          <div className="spinner-small"></div>
          <p>Loading more...</p>
        </div>
      )}
      
      {!loading && recommendations.length > 0 && (
        <div className="feed-stats">
          Showing {recommendations.length} of {totalCount} recommendations
        </div>
      )}
    </div>
  );
};

export default RecommendationFeed;

// client/src/pages/HomePage.tsx
import React from 'react';
import { Helmet } from 'react-helmet';
import { Link } from 'react-router-dom';
import RecommendationFeed from '../components/recommendations/RecommendationFeed';

const HomePage: React.FC = () => {
  const isAuthenticated = !!localStorage.getItem('authToken');

  return (
    <div className="home-page">
      <Helmet>
        <title>Murmur - Voice Recommendations</title>
        <meta name="description" content="Discover voice-based recommendations from real people" />
      </Helmet>

      <div className="hero-section">
        <div className="hero-content">
          <h1 className="hero-title">Hear authentic recommendations</h1>
          <p className="hero-subtitle">
            Real voices. Real opinions. Discover products, places, and experiences
            recommended by real people.
          </p>
          
          {isAuthenticated ? (
            <Link to="/record" className="cta-button">
              Share Your Recommendation
            </Link>
          ) : (
            <div className="auth-cta">
              <Link to="/login" className="login-button">
                Log In
              </Link>
              <Link to="/register" className="register-button">
                Sign Up
              </Link>
            </div>
          )}
        </div>
      </div>

      <div className="popular-categories">
        <h2>Popular Categories</h2>
        <div className="categories-grid">
          {['Food', 'Travel', 'Books', 'Technology'].map(category => (
            <div key={category} className="category-card">
              <h3>{category}</h3>
              <p>Discover {category.toLowerCase()} recommendations</p>
            </div>
          ))}
        </div>
      </div>

      <div className="main-content">
        <h2>Latest Recommendations</h2>
        <RecommendationFeed />
      </div>

      <div className="app-download">
        <div className="download-content">
          <h2>Take Murmur with you</h2>
          <p>Download our mobile app and discover recommendations on the go.</p>
          <div className="download-buttons">
            <a href="#" className="app-store-button">App Store</a>
            <a href="#" className="play-store-button">Google Play</a>
          </div>
        </div>
      </div>
    </div>
  );
};

export default HomePage;

// client/src/pages/ProfilePage.tsx
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Helmet } from 'react-helmet';
import { fetchUser, fetchUserRecommendations, listenToUser, muteUser } from '../api/users';
import { User, Recommendation } from '../types';
import RecommendationCard from '../components/recommendations/RecommendationCard';
import toast from 'react-hot-toast';

const ProfilePage: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const [user, setUser] = useState<User | null>(null);
  const [recommendations, setRecommendations] = useState<Recommendation[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const [isListening, setIsListening] = useState(false);
  
  // Get the current user ID from localStorage
  const currentUserId = localStorage.getItem('userId');
  const isOwnProfile = currentUserId === id;

  // Fetch user profile and initial recommendations
  useEffect(() => {
    const loadProfile = async () => {
      if (!id) return;
      
      try {
        setLoading(true);
        setError(null);
        
        // Fetch user profile
        const userData = await fetchUser(id);
        setUser(userData);
        
        // Check if current user is listening to this profile
        setIsListening(userData.listenersCount > 0); // This is a simplification; would need a proper endpoint
        
        // Fetch user's recommendations
        const result = await fetchUserRecommendations(id, 1, 5);
        setRecommendations(result.recommendations);
        setHasMore(result.recommendations.length === 5);
        
      } catch (err) {
        console.error('Error loading profile:', err);
        setError('Failed to load user profile. The user may not exist or has been removed.');
      } finally {
        setLoading(false);
      }
    };
    
    loadProfile();
  }, [id]);

  // Load more recommendations
  const loadMoreRecommendations = async () => {
    if (!id || !hasMore || loading) return;
    
    try {
      setLoading(true);
      const nextPage = page + 1;
      const result = await fetchUserRecommendations(id, nextPage, 5);
      
      if (result.recommendations.length > 0) {
        setRecommendations(prev => [...prev, ...result.recommendations]);
        setPage(nextPage);
      }
      
      setHasMore(result.recommendations.length === 5);
    } catch (err) {
      console.error('Error loading more recommendations:', err);
      toast.error('Failed to load more recommendations');
    } finally {
      setLoading(false);
    }
  };

  // Handle listen/unfollow functionality
  const handleListenToggle = async () => {
    if (!id || !user) return;
    
    try {
      if (isListening) {
        await muteUser(id);
        setIsListening(false);
        toast.success(`You are no longer listening to ${user.name}`);
      } else {
        await listenToUser(id);
        setIsListening(true);
        toast.success(`You are now listening to ${user.name}`);
      }
      
      // Update the user object with the new count
      setUser(prev => {
        if (!prev) return prev;
        return {
          ...prev,
          listenersCount: isListening 
            ? Math.max(0, prev.listenersCount - 1)
            : prev.listenersCount + 1
        };
      });
    } catch (err) {
      console.error('Error toggling listen status:', err);
      toast.error('Failed to update listening status');
    }
  };

  // Handle sharing a recommendation
  const handleShare = (recommendationId: string) => {
    const shareUrl = `${window.location.origin}/recommendations/${recommendationId}`;
    
    if (navigator.share) {
      navigator.share({
        title: `Check out this recommendation by ${user?.name}`,
        url: shareUrl
      }).catch(err => {
        console.error('Error sharing:', err);
      });
    } else {
      // Fallback to clipboard copy
      navigator.clipboard.writeText(shareUrl).then(() => {
        toast.success('Link copied to clipboard!');
      }).catch(err => {
        console.error('Error copying to clipboard:', err);
        toast.error('Failed to copy link');
      });
    }
  };

  // Handle reactions (like/dislike)
  const handleReaction = (id: string, reaction: 'like' | 'dislike') => {
    // This would typically call an API endpoint to record the reaction
    toast.success(`You ${reaction}d this recommendation!`);
  };

  // Handle sharing the profile
  const handleShareProfile = () => {
    if (!user) return;
    
    const profileUrl = `${window.location.origin}/profile/${id}`;
    
    if (navigator.share) {
      navigator.share({
        title: `Check out ${user.name} on Murmur`,
        url: profileUrl
      }).catch(err => {
        console.error('Error sharing:', err);
      });
    } else {
      // Fallback to clipboard copy
      navigator.clipboard.writeText(profileUrl).then(() => {
        toast.success('Profile link copied to clipboard!');
      }).catch(err => {
        console.error('Error copying to clipboard:', err);
        toast.error('Failed to copy profile link');
      });
    }
  };

  if (error) {
    return (
      <div className="error-container">
        <h2>Error</h2>
        <p>{error}</p>
        <button onClick={() => navigate('/')} className="back-button">
          Go to Homepage
        </button>
      </div>
    );
  }

  if (loading && !user) {
    return (
      <div className="loading-container">
        <div className="spinner"></div>
        <p>Loading profile...</p>
      </div>
    );
  }

  if (!user) {
    return null;
  }

  return (
    <div className="profile-page">
      <Helmet>
        <title>{user.name} | Murmur</title>
        <meta name="description" content={`Check out ${user.name}'s recommendations on Murmur`} />
      </Helmet>

      <div className="profile-header">
        <div className="profile-cover-photo"></div>
        
        <div className="profile-info">
          <div className="profile-avatar">
            <img 
              src={user.profilePic || '/assets/default-avatar.png'} 
              alt={user.name} 
              className="avatar-image"
            />
          </div>
          
          <div className="profile-details">
            <h1 className="profile-name">{user.name}</h1>
            
            <p className="profile-bio">
              {user.bio || 'No bio available'}
            </p>
            
            <div className="profile-stats">
              <div className="stat">
                <span className="stat-value">{user.listenersCount}</span>
                <span className="stat-label">Listeners</span>
              </div>
              <div className="stat">
                <span className="stat-value">{user.listeningCount}</span>
                <span className="stat-label">Listening</span>
              </div>
              <div className="stat">
                <span className="stat-value">{recommendations.length}</span>
                <span className="stat-label">Recommendations</span>
              </div>
            </div>
            
            <div className="profile-actions">
              {!isOwnProfile && (
                <button 
                  className={`listen-button ${isListening ? 'listening' : ''}`}
                  onClick={handleListenToggle}
                >
                  {isListening ? 'Listening' : 'Listen'}
                </button>
              )}
              
              {isOwnProfile && (
                <button 
                  className="edit-profile-button"
                  onClick={() => navigate('/settings/profile')}
                >
                  Edit Profile
                </button>
              )}
              
              <button 
                className="share-profile-

