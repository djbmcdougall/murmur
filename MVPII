// PROJECT STRUCTURE
/**
 * /
 * ├── client/                  # Frontend React application
 * │   ├── public/              # Static assets
 * │   ├── src/
 * │   │   ├── api/             # API client with typed endpoints
 * │   │   ├── components/      # React components
 * │   │   ├── hooks/           # Custom React hooks
 * │   │   ├── pages/           # Page components
 * │   │   ├── store/           # Redux state management
 * │   │   ├── types/           # TypeScript type definitions
 * │   │   ├── utils/           # Utility functions
 * │   │   ├── App.tsx          # Main App component
 * │   │   ├── index.tsx        # Entry point
 * │   ├── package.json         # Frontend dependencies
 * │   ├── tsconfig.json        # TypeScript configuration
 * ├── server/                  # Backend Node.js application
 * │   ├── src/
 * │   │   ├── config/          # Configuration files
 * │   │   ├── controllers/     # Route controllers
 * │   │   ├── middleware/      # Express middleware
 * │   │   ├── models/          # Database models
 * │   │   ├── routes/          # API routes
 * │   │   ├── services/        # Business logic
 * │   │   ├── types/           # TypeScript type definitions
 * │   │   ├── utils/           # Utility functions
 * │   │   ├── app.ts           # Express app setup
 * │   │   ├── server.ts        # Server entry point
 * │   ├── package.json         # Backend dependencies
 * │   ├── tsconfig.json        # TypeScript configuration
 * ├── docker/                  # Docker configuration
 * │   ├── docker-compose.yml   # Multi-container setup
 * │   ├── Dockerfile.client    # Frontend container
 * │   ├── Dockerfile.server    # Backend container
 * ├── .github/                 # GitHub workflows for CI/CD
 * ├── README.md                # Project documentation
 * ├── LICENSE                  # License information
 */

# Create React TypeScript app
npx create-react-app client --template typescript

# Navigate to client directory
cd client

# Install dependencies
npm install @reduxjs/toolkit react-redux axios material-ui @emotion/react @emotion/styled framer-motion tailwindcss postcss autoprefixer react-router-dom react-infinite-scroll-component websocket

# Install dev dependencies
npm install --save-dev @types/react-redux @types/websocket

# Initialize Tailwind CSS
npx tailwindcss init -p

# Create server directory
mkdir -p server/src/{config,controllers,middleware,models,routes,services,types,utils}

# Navigate to server directory
cd server

# Initialize package.json
npm init -y

# Install dependencies
npm install express cors dotenv helmet morgan mongoose pg winston google-cloud/speech @google-cloud/speech socket.io jsonwebtoken bcrypt

# Install dev dependencies
npm install --save-dev typescript ts-node nodemon @types/express @types/cors @types/morgan @types/pg @types/bcrypt @types/jsonwebtoken

# Initialize TypeScript configuration
npx tsc --init

// server/src/services/speechToTextService.ts
import speech from '@google-cloud/speech';
import fs from 'fs';
import { promisify } from 'util';
import path from 'path';

// Create client with credentials
const client = new speech.SpeechClient({
  keyFilename: path.join(__dirname, '../../config/google-credentials.json')
});

export interface SpeechToTextResult {
  text: string;
  confidence: number;
}

/**
 * Converts audio file to text using Google Speech-to-Text API
 * @param audioFilePath Path to the audio file
 * @returns Transcribed text and confidence score
 */
export const convertAudioToText = async (audioFilePath: string): Promise<SpeechToTextResult> => {
  try {
    // Read audio file
    const readFile = promisify(fs.readFile);
    const audioBytes = await readFile(audioFilePath);
    const audio = {
      content: audioBytes.toString('base64'),
    };

    // Configure request
    const config = {
      encoding: 'LINEAR16',
      sampleRateHertz: 16000,
      languageCode: 'en-US',
      enableAutomaticPunctuation: true,
      model: 'phone_call', // Optimized for voice recordings
    };

    const request = {
      audio: audio,
      config: config,
    };

    // Perform speech recognition
    const [response] = await client.recognize(request);
    const transcription = response.results
      ?.map(result => result.alternatives?.[0]?.transcript)
      .filter(Boolean)
      .join('\n') || '';
    
    const confidence = response.results?.[0]?.alternatives?.[0]?.confidence || 0;

    return {
      text: transcription,
      confidence: confidence
    };
  } catch (error) {
    console.error('Error in speech to text conversion:', error);
    throw new Error('Failed to convert speech to text');
  }
};

export default {
  convertAudioToText
};

// server/src/services/sentimentService.ts
import { spawn } from 'child_process';
import path from 'path';

export interface SentimentResult {
  text: string;
  sentiment: {
    polarity: number;  // Range from -1 (negative) to 1 (positive)
    subjectivity: number;  // Range from 0 (factual) to 1 (subjective)
  };
  entities: Array<{
    text: string;
    label: string;
    start: number;
    end: number;
  }>;
  keywords: string[];
}

/**
 * Analyzes text sentiment using spaCy through a Python script
 * @param text Text to analyze
 * @returns Sentiment analysis results
 */
export const analyzeSentiment = async (text: string): Promise<SentimentResult> => {
  return new Promise((resolve, reject) => {
    try {
      const scriptPath = path.join(__dirname, '../python/sentiment_analysis.py');
      const process = spawn('python', [scriptPath, text]);
      
      let result = '';
      
      process.stdout.on('data', (data) => {
        result += data.toString();
      });
      
      process.stderr.on('data', (data) => {
        console.error(`Error from Python script: ${data}`);
      });
      
      process.on('close', (code) => {
        if (code !== 0) {
          return reject(new Error(`Process exited with code ${code}`));
        }
        
        try {
          const parsedResult = JSON.parse(result);
          resolve(parsedResult);
        } catch (error) {
          reject(new Error('Failed to parse sentiment analysis result'));
        }
      });
    } catch (error) {
      reject(error);
    }
  });
};

export default {
  analyzeSentiment
};

# server/src/python/sentiment_analysis.py
import sys
import json
import spacy
from spacytextblob.spacytextblob import SpacyTextBlob

# Load spaCy model
nlp = spacy.load('en_core_web_md')
nlp.add_pipe('spacytextblob')

def analyze_sentiment(text):
    # Process text with spaCy
    doc = nlp(text)
    
    # Extract sentiment
    polarity = doc._.blob.polarity
    subjectivity = doc._.blob.subjectivity
    
    # Extract entities
    entities = [
        {
            "text": ent.text,
            "label": ent.label_,
            "start": ent.start_char,
            "end": ent.end_char
        }
        for ent in doc.ents
    ]
    
    # Extract keywords (nouns and proper nouns)
    keywords = [token.text for token in doc if token.pos_ in ('NOUN', 'PROPN') and not token.is_stop]
    
    # Return results
    return {
        "text": text,
        "sentiment": {
            "polarity": polarity,
            "subjectivity": subjectivity
        },
        "entities": entities,
        "keywords": list(set(keywords))  # Remove duplicates
    }

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(json.dumps({"error": "No text provided"}))
        sys.exit(1)
    
    text = sys.argv[1]
    result = analyze_sentiment(text)
    print(json.dumps(result))

// server/src/models/Recommendation.ts
import mongoose, { Document, Schema } from 'mongoose';

export interface IRecommendation extends Document {
  userId: mongoose.Types.ObjectId;
  title: string;
  content: string;
  audioUrl: string;
  audioDuration: number;
  categories: string[];
  sentiment: {
    polarity: number;
    subjectivity: number;
  };
  keywords: string[];
  likes: number;
  views: number;
  createdAt: Date;
  updatedAt: Date;
}

const RecommendationSchema: Schema = new Schema({
  userId: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  title: {
    type: String,
    required: true,
    trim: true
  },
  content: {
    type: String,
    required: true
  },
  audioUrl: {
    type: String,
    required: true
  },
  audioDuration: {
    type: Number,
    required: true
  },
  categories: [{
    type: String,
    required: true
  }],
  sentiment: {
    polarity: {
      type: Number,
      required: true
    },
    subjectivity: {
      type: Number,
      required: true
    }
  },
  keywords: [{
    type: String
  }],
  likes: {
    type: Number,
    default: 0
  },
  views: {
    type: Number,
    default: 0
  }
}, {
  timestamps: true
});

// Create text index for search functionality
RecommendationSchema.index({ 
  title: 'text', 
  content: 'text',
  keywords: 'text'
});

export default mongoose.model<IRecommendation>('Recommendation', RecommendationSchema);

// server/src/models/User.ts
import mongoose, { Document, Schema } from 'mongoose';
import bcrypt from 'bcrypt';

export interface IUser extends Document {
  username: string;
  email: string;
  password: string;
  profilePicture: string;
  bio: string;
  listeners: mongoose.Types.ObjectId[];
  listening: mongoose.Types.ObjectId[];
  muted: mongoose.Types.ObjectId[];
  badges: string[];
  recommendations: mongoose.Types.ObjectId[];
  streak: number;
  lastRecommendation: Date;
  comparePassword(candidatePassword: string): Promise<boolean>;
}

const UserSchema: Schema = new Schema({
  username: {
    type: String,
    required: true,
    unique: true,
    trim: true
  },
  email: {
    type: String,
    required: true,
    unique: true,
    trim: true,
    lowercase: true
  },
  password: {
    type: String,
    required: true
  },
  profilePicture: {
    type: String,
    default: 'default-profile.png'
  },
  bio: {
    type: String,
    default: ''
  },
  listeners: [{
    type: Schema.Types.ObjectId,
    ref: 'User'
  }],
  listening: [{
    type: Schema.Types.ObjectId,
    ref: 'User'
  }],
  muted: [{
    type: Schema.Types.ObjectId,
    ref: 'User'
  }],
  badges: [{
    type: String
  }],
  recommendations: [{
    type: Schema.Types.ObjectId,
    ref: 'Recommendation'
  }],
  streak: {
    type: Number,
    default: 0
  },
  lastRecommendation: {
    type: Date
  }
}, {
  timestamps: true
});

// Pre-save hook to hash password
UserSchema.pre<IUser>('save', async function(next) {
  // Only hash the password if it's modified or new
  if (!this.isModified('password')) return next();
  
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error as Error);
  }
});

// Method to compare passwords
UserSchema.methods.comparePassword = async function(candidatePassword: string): Promise<boolean> {
  return bcrypt.compare(candidatePassword, this.password);
};

export default mongoose.model<IUser>('User', UserSchema);

// server/src/services/storageService.ts
import fs from 'fs';
import path from 'path';
import { promisify } from 'util';
import AWS from 'aws-sdk';
import { v4 as uuidv4 } from 'uuid';

// Configure AWS S3
const s3 = new AWS.S3({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION
});

const bucketName = process.env.AWS_S3_BUCKET_NAME || 'murmur-audio';

/**
 * Uploads an audio file to AWS S3
 * @param file Express file object
 * @returns URL of the uploaded file
 */
export const uploadAudio = async (file: Express.Multer.File): Promise<string> => {
  try {
    const fileContent = await promisify(fs.readFile)(file.path);
    const fileExtension = path.extname(file.originalname);
    const fileName = `${uuidv4()}${fileExtension}`;
    
    const uploadParams = {
      Bucket: bucketName,
      Key: `audio/${fileName}`,
      Body: fileContent,
      ContentType: file.mimetype,
      ACL: 'public-read'
    };
    
    const result = await s3.upload(uploadParams).promise();
    
    // Clean up temp file
    await promisify(fs.unlink)(file.path);
    
    return result.Location;
  } catch (error) {
    console.error('Error uploading audio to S3:', error);
    throw new Error('Failed to upload audio');
  }
};

/**
 * Delete an audio file from AWS S3
 * @param audioUrl URL of the audio file to delete
 */
export const deleteAudio = async (audioUrl: string): Promise<void> => {
  try {
    // Extract key from URL
    const key = audioUrl.split(`${bucketName}/`)[1];
    
    const deleteParams = {
      Bucket: bucketName,
      Key: key
    };
    
    await s3.deleteObject(deleteParams).promise();
  } catch (error) {
    console.error('Error deleting audio from S3:', error);
    throw new Error('Failed to delete audio');
  }
};

export default {
  uploadAudio,
  deleteAudio
};

// server/src/controllers/userController.ts
import { Request, Response } from 'express';
import User from '../models/User';
import jwt from 'jsonwebtoken';
import mongoose from 'mongoose';

// Register a new user
export const register = async (req: Request, res: Response) => {
  try {
    const { username, email, password } = req.body;

    // Check if user already exists
    const userExists = await User.findOne({ 
      $or: [{ username }, { email }] 
    });

    if (userExists) {
      return res.status(400).json({ message: 'Username or email already in use' });
    }

    // Create new user
    const user = new User({
      username,
      email,
      password
    });

    await user.save();

    // Create token
    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET as string, {
      expiresIn: '30d'
    });

    res.status(201).json({
      _id: user._id,
      username: user.username,
      email: user.email,
      profilePicture: user.profilePicture,
      token
    });
  } catch (error) {
    console.error('Error registering user:', error);
    res.status(500).json({ message: 'Failed to register user' });
  }
};

// Login user
export const login = async (req: Request, res: Response) => {
  try {
    const { email, password } = req.body;

    // Find user
    const user = await User.findOne({ email });

    if (!user) {
      return res.status(401).json({ message: 'Invalid email or password' });
    }

    // Check password
    const isMatch = await user.comparePassword(password);

    if (!isMatch) {
      return res.status(401).json({ message: 'Invalid email or password' });
    }

    // Create token
    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET as string, {
      expiresIn: '30d'
    });

    res.status(200).json({
      _id: user._id,
      username: user.username,
      email: user.email,
      profilePicture: user.profilePicture,
      token
    });
  } catch (error) {
    console.error('Error logging in:', error);
    res.status(500).json({ message: 'Failed to login' });
  }
};

// Get user profile
export const getProfile = async (req: Request, res: Response) => {
  try {
    const { username } = req.params;

    const user = await User.findOne({ username })
      .select('-password -email')
      .populate('recommendations', 'title createdAt views likes');

    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    res.status(200).json(user);
  } catch (error) {
    console.error('Error fetching user profile:', error);
    res.status(500).json({ message: 'Failed to fetch user profile' });
  }
};

// Listen to a user
export const listenToUser = async (req: Request, res: Response) => {
  try {
    const { userId } = req.params;
    const currentUserId = req.user?.id;

    if (!mongoose.Types.ObjectId.isValid(userId)) {
      return res.status(400).json({ message: 'Invalid user ID' });
    }

    if (userId === currentUserId) {
      return res.status(400).json({ message: 'You cannot listen to yourself' });
    }

    const [currentUser, targetUser] = await Promise.all([
      User.findById(currentUserId),
      User.findById(userId)
    ]);

    if (!currentUser || !targetUser) {
      return res.status(404).json({ message: 'User not found' });
    }

    // Check if already listening
    if (currentUser.listening.includes(targetUser._id)) {
      return res.status(400).json({ message: 'Already listening to this user' });
    }

    // Update current user's listening list
    currentUser.listening.push(targetUser._id);
    
    // Update target user's listeners list
    targetUser.listeners.push(currentUser._id);

    await Promise.all([currentUser.save(), targetUser.save()]);

    res.status(200).json({ message: 'Successfully listening to user' });
  } catch (error) {
    console.error('Error listening to user:', error);
    res.status(500).json({ message: 'Failed to listen to user' });
  }
};

// Mute a user
export const muteUser = async (req: Request, res: Response) => {
  try {
    const { userId } = req.params;
    const currentUserId = req.user?.id;

    if (!mongoose.Types.ObjectId.isValid(userId)) {
      return res.status(400).json({ message: 'Invalid user ID' });
    }

    if (userId === currentUserId) {
      return res.status(400).json({ message: 'You cannot mute yourself' });
    }

    const currentUser = await User.findById(currentUserId);

    if (!currentUser) {
      return res.status(404).json({ message: 'User not found' });
    }

    // Check if already muted
    if (currentUser.muted.includes(userId)) {
      return res.status(400).json({ message: 'User already muted' });
    }

    // Add to muted list
    currentUser.muted.push(userId);
    await currentUser.save();

    res.status(200).json({ message: 'User muted successfully' });
  } catch (error) {
    console.error('Error muting user:', error);
    res.status(500).json({ message: 'Failed to mute user' });
  }
};

export default {
  register,
  login,
  getProfile,
  listenToUser,
  muteUser
};

// server/src/routes/index.ts
import { Router } from 'express';
import userRoutes from './userRoutes';
import recommendationRoutes from './recommendationRoutes';

const router = Router();

// Root route
router.get('/', (req, res) => {
  res.json({ message: 'Welcome to Murmur API' });
});

// API routes
router.use('/users', userRoutes);
router.use('/recommendations', recommendationRoutes);

export default router;

// server/src/routes/userRoutes.ts
import { Router } from 'express';
import userController from '../controllers/userController';
import { protect } from '../middleware/authMiddleware';

const router = Router();

// Public routes
router.post('/register', userController.register);
router.post('/login', userController.login);
router.get('/profile/:username', userController.getProfile);

// Protected routes
router.post('/listen/:userId', protect, userController.listenToUser);
router.post('/mute/:userId', protect, userController.muteUser);

export default router;

// server/src/routes/recommendationRoutes.ts
import { Router } from 'express';
import recommendationController from '../controllers/recommendationController';
import { protect } from '../middleware/authMiddleware';
import upload from '../middleware/uploadMiddleware';

const router = Router();

// Public routes
router.get('/', recommendationController.getFeed);
router.get('/:id', recommendationController.getRecommendationById);

// Protected routes
router.post('/', protect, upload.single('audio'), recommendationController.createRecommendation);
router.post('/:id/like', protect, recommendationController.likeRecommendation);

export default router;

// server/src/routes/index.ts
import { Router } from 'express';
import userRoutes from './userRoutes';
import recommendationRoutes from './recommendationRoutes';

const router = Router();

// Root route
router.get('/', (req, res) => {
  res.json({ message: 'Welcome to Murmur API' });
});

// API routes
router.use('/users', userRoutes);
router.use('/recommendations', recommendationRoutes);

export default router;

// server/src/routes/userRoutes.ts
import { Router } from 'express';
import userController from '../controllers/userController';
import { protect } from '../middleware/authMiddleware';

const router = Router();

// Public routes
router.post('/register', userController.register);
router.post('/login', userController.login);
router.get('/profile/:username', userController.getProfile);

// Protected routes
router.post('/listen/:userId', protect, userController.listenToUser);
router.post('/mute/:userId', protect, userController.muteUser);

export default router;

// server/src/routes/recommendationRoutes.ts
import { Router } from 'express';
import recommendationController from '../controllers/recommendationController';
import { protect } from '../middleware/authMiddleware';
import upload from '../middleware/uploadMiddleware';

const router = Router();

// Public routes
router.get('/', recommendationController.getFeed);
router.get('/:id', recommendationController.getRecommendationById);

// Protected routes
router.post('/', protect, upload.single('audio'), recommendationController.createRecommendation);
router.post('/:id/like', protect, recommendationController.likeRecommendation);

export default router;

// server/src/middleware/authMiddleware.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import User from '../models/User';

// Extend Express Request type to include user
declare global {
  namespace Express {
    interface Request {
      user?: {
        id: string;
      };
    }
  }
}

/**
 * Middleware to protect routes
 * Verifies JWT token and adds user ID to request
 */
export const protect = async (req: Request, res: Response, next: NextFunction) => {
  try {
    let token;

    // Check for token in Authorization header
    if (
      req.headers.authorization &&
      req.headers.authorization.startsWith('Bearer')
    ) {
      token = req.headers.authorization.split(' ')[1];
    }

    if (!token) {
      return res.status(401).json({ message: 'Not authorized, no token' });
    }

    // Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET as string) as { id: string };

    // Check if user exists
    const userExists = await User.findById(decoded.id).select('-password');

    if (!userExists) {
      return res.status(401).json({ message: 'Not authorized, user not found' });
    }

    // Add user to request
    req.user = { id: decoded.id };
    next();
  } catch (error) {
    console.error('Auth middleware error:', error);
    res.status(401).json({ message: 'Not authorized, token failed' });
  }
};

// server/src/middleware/uploadMiddleware.ts
import multer from 'multer';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';
import fs from 'fs';

// Create uploads directory if it doesn't exist
const uploadDir = path.join(__dirname, '../../uploads');
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}

// Configure storage
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueFilename = `${uuidv4()}${path.extname(file.originalname)}`;
    cb(null, uniqueFilename);
  }
});

// File filter to only allow audio files
const fileFilter = (req: Express.Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  const allowedMimeTypes = [
    'audio/mpeg',
    'audio/mp3',
    'audio/wav',
    'audio/ogg',
    'audio/webm'
  ];

  if (allowedMimeTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only audio files are allowed.'));
  }
};

// Configure multer
const upload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB limit
  }
});

export default upload;

// server/src/index.ts
import express, { Request, Response, NextFunction } from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import dotenv from 'dotenv';
import path from 'path';
import http from 'http';
import mongoose from 'mongoose';
import { Server as SocketIOServer } from 'socket.io';
import routes from './routes';

// Load environment variables
dotenv.config();

// Create Express app
const app = express();
const server = http.createServer(app);
const io = new SocketIOServer(server, {
  cors: {
    origin: process.env.CLIENT_URL || 'http://localhost:3000',
    methods: ['GET', 'POST']
  }
});

// Connect to MongoDB
mongoose.connect(process.env.MONGODB_URI as string)
  .then(() => {
    console.log('Connected to MongoDB');
  })
  .catch((error) => {
    console.error('MongoDB connection error:', error);
    process.exit(1);
  });

// Middleware
app.use(cors());
app.use(helmet());
app.use(morgan('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Serve static files from uploads directory
app.use('/uploads', express.static(path.join(__dirname, '../uploads')));

// API routes
app.use('/api', routes);

// Error handling middleware
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  console.error('Error:', err);
  res.status(500).json({ message: err.message || 'An unexpected error occurred' });
});

// WebSocket connections
io.on('connection', (socket) => {
  console.log('New client connected:', socket.id);

  socket.on('disconnect', () => {
    console.log('Client disconnected:', socket.id);
  });

  // Real-time notification for new recommendations
  socket.on('join-feed', () => {
    socket.join('feed');
  });

  // Real-time notification for user profile
  socket.on('join-user', (username: string) => {
    socket.join(`user:${username}`);
  });
});

// Export for real-time notifications
export { io };

// Start server
const PORT = process.env.PORT || 5000;
server.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

# Server Configuration
PORT=5000
NODE_ENV=development
CLIENT_URL=http://localhost:3000

# MongoDB Connection
MONGODB_URI=mongodb://localhost:27017/murmur

# JWT Secret
JWT_SECRET=your_jwt_secret_key_here

# AWS S3 Configuration
AWS_ACCESS_KEY_ID=your_aws_access_key_id
AWS_SECRET_ACCESS_KEY=your_aws_secret_access_key
AWS_REGION=us-east-1
AWS_S3_BUCKET_NAME=murmur-audio

# Google Cloud Configuration
GOOGLE_APPLICATION_CREDENTIALS=./config/google-credentials.json

// client/src/redux/store.ts
import { configureStore } from '@reduxjs/toolkit';
import authReducer from './slices/authSlice';
import recommendationReducer from './slices/recommendationSlice';
import userReducer from './slices/userSlice';
import notificationReducer from './slices/notificationSlice';

const store = configureStore({
  reducer: {
    auth: authReducer,
    recommendations: recommendationReducer,
    user: userReducer,
    notifications: notificationReducer
  }
});

// Infer the `RootState` and `AppDispatch` types from the store itself
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

export default store;

// client/src/redux/slices/authSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import axios from 'axios';

interface User {
  _id: string;
  username: string;
  email: string;
  profilePicture: string;
  token: string;
}

interface AuthState {
  user: User | null;
  isLoading: boolean;
  error: string | null;
}

interface LoginCredentials {
  email: string;
  password: string;
}

interface RegisterCredentials {
  username: string;
  email: string;
  password: string;
}

const initialState: AuthState = {
  user: localStorage.getItem('user') 
    ? JSON.parse(localStorage.getItem('user') as string) 
    : null,
  isLoading: false,
  error: null
};

// Login user
export const login = createAsyncThunk(
  'auth/login',
  async (credentials: LoginCredentials, { rejectWithValue }) => {
    try {
      const { data } = await axios.post('/api/users/login', credentials);
      localStorage.setItem('user', JSON.stringify(data));
      return data;
    } catch (error: any) {
      return rejectWithValue(
        error.response?.data?.message || 'Failed to login'
      );
    }
  }
);

// Register user
export const register = createAsyncThunk(
  'auth/register',
  async (credentials: RegisterCredentials, { rejectWithValue }) => {
    try {
      const { data } = await axios.post('/api/users/register', credentials);
      localStorage.setItem('user', JSON.stringify(data));
      return data;
    } catch (error: any) {
      return rejectWithValue(
        error.response?.data?.message || 'Failed to register'
      );
    }
  }
);

// Logout user
export const logout = createAsyncThunk('auth/logout', async () => {
  localStorage.removeItem('user');
  return null;
});

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    resetError: (state) => {
      state.error = null;
    }
  },
  extraReducers: (builder) => {
    builder
      // Login cases
      .addCase(login.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(login.fulfilled, (state, action: PayloadAction<User>) => {
        state.isLoading = false;
        state.user = action.payload;
      })
      .addCase(login.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
      // Register cases
      .addCase(register.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(register.fulfilled, (state, action: PayloadAction<User>) => {
        state.isLoading = false;
        state.user = action.payload;
      })
      .addCase(register.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
      // Logout cases
      .addCase(logout.fulfilled, (state) => {
        state.user = null;
      });
  }
});

export const { resetError } = authSlice.actions;
export default authSlice.reducer;

// client/src/redux/slices/recommendationSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import axios from 'axios';
import { RootState } from '../store';

interface User {
  _id: string;
  username: string;
  profilePicture: string;
}

interface Recommendation {
  _id: string;
  userId: User;
  title: string;
  content: string;
  audioUrl: string;
  audioDuration: number;
  categories: string[];
  sentiment: {
    polarity: number;
    subjectivity: number;
  };
  keywords: string[];
  likes: number;
  views: number;
  createdAt: string;
}

interface RecommendationState {
  feed: Recommendation[];
  currentRecommendation: Recommendation | null;
  pagination: {
    page: number;
    pages: number;
    total: number;
  };
  isLoading: boolean;
  error: string | null;
  selectedCategory: string;
}

interface FeedResponse {
  data: Recommendation[];
  pagination: {
    page: number;
    pages: number;
    total: number;
  };
}

interface FeedParams {
  page?: number;
  category?: string;
}

const initialState: RecommendationState = {
  feed: [],
  currentRecommendation: null,
  pagination: {
    page: 1,
    pages: 1,
    total: 0
  },
  isLoading: false,
  error: null,
  selectedCategory: 'all'
};

// Get recommendations feed
export const fetchFeed = createAsyncThunk<
  FeedResponse,
  FeedParams,
  { state: RootState }
>(
  'recommendations/fetchFeed',
  async ({ page = 1, category = 'all' }, { getState, rejectWithValue }) => {
    try {
      const { auth } = getState();
      const config = auth.user 
        ? { headers: { Authorization: `Bearer ${auth.user.token}` } }
        : {};

      let url = `/api/recommendations?page=${page}`;
      if (category !== 'all') {
        url += `&category=${category}`;
      }

      const { data } = await axios.get<FeedResponse>(url, config);
      return data;
    } catch (error: any) {
      return rejectWithValue(
        error.response?.data?.message || 'Failed to fetch recommendations'
      );
    }
  }
);

// Get recommendation by ID
export const fetchRecommendationById = createAsyncThunk<
  Recommendation,
  string,
  { state: RootState }
>(
  'recommendations/fetchById',
  async (id, { getState, rejectWithValue }) => {
    try {
      const { auth } = getState();
      const config = auth.user 
        ? { headers: { Authorization: `Bearer ${auth.user.token}` } }
        : {};

      const { data } = await axios.get<Recommendation>(
        `/api/recommendations/${id}`,
        config
      );
      return data;
    } catch (error: any) {
      return rejectWithValue(
        error.response?.data?.message || 'Failed to fetch recommendation'
      );
    }
  }
);

// Create recommendation
export const createRecommendation = createAsyncThunk<
  Recommendation,
  FormData,
  { state: RootState }
>(
  'recommendations/create',
  async (formData, { getState, rejectWithValue }) => {
    try {
      const { auth } = getState();
      
      if (!auth.user) {
        return rejectWithValue('Not authenticated');
      }

      const config = {
        headers: { 
          Authorization: `Bearer ${auth.user.token}`,
          'Content-Type': 'multipart/form-data'
        }
      };

      const { data } = await axios.post<Recommendation>(
        '/api/recommendations',
        formData,
        config
      );
      return data;
    } catch (error: any) {
      return rejectWithValue(
        error.response?.data?.message || 'Failed to create recommendation'
      );
    }
  }
);

// Like recommendation
export const likeRecommendation = createAsyncThunk<
  { likes: number, id: string },
  string,
  { state: RootState }
>(
  'recommendations/like',
  async (id, { getState, rejectWithValue }) => {
    try {
      const { auth } = getState();
      
      if (!auth.user) {
        return rejectWithValue('Not authenticated');
      }

      const config = {
        headers: { 
          Authorization: `Bearer ${auth.user.token}`
        }
      };

      const { data } = await axios.post<{ likes: number }>(
        `/api/recommendations/${id}/like`,
        {},
        config
      );
      return { likes: data.likes, id };
    } catch (error: any) {
      return rejectWithValue(
        error.response?.data?.message || 'Failed to like recommendation'
      );
    }
  }
);

const recommendationSlice = createSlice({
  name: 'recommendations',
  initialState,
  reducers: {
    resetRecommendations: (state) => {
      state.feed = [];
      state.pagination.page = 1;
    },
    setCategory: (state, action: PayloadAction<string>) => {
      state.selectedCategory = action.payload;
      state.feed = [];
      state.pagination.page = 1;
    },
    clearCurrentRecommendation: (state) => {
      state.currentRecommendation = null;
    }
  },
  extraReducers: (builder) => {
    builder
      // Fetch feed cases
      .addCase(fetchFeed.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchFeed.fulfilled, (state, action) => {
        state.isLoading = false;
        // If it's page 1 or we're changing categories, replace the feed
        if (state.pagination.page === 1) {
          state.feed = action.payload.data;
        } else {
          // Otherwise, append to the feed
          state.feed = [...state.feed, ...action.payload.data];
        }
        state.pagination = action.payload.pagination;
      })
      .addCase(fetchFeed.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
      // Fetch by ID cases
      .addCase(fetchRecommendationById.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchRecommendationById.fulfilled, (state, action) => {
        state.isLoading = false;
        state.currentRecommendation = action.payload;
      })
      .addCase(fetchRecommendationById.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
      // Create recommendation cases
      .addCase(createRecommendation.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(createRecommendation.fulfilled, (state, action) => {
        state.isLoading = false;
        state.feed = [action.payload, ...state.feed];
        state.pagination.total += 1;
      })
      .addCase(createRecommendation.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
      // Like recommendation cases
      .addCase(likeRecommendation.fulfilled, (state, action) => {
        // Update likes in feed
        const recommendation = state.feed.find(r => r._id === action.payload.id);
        if (recommendation) {
          recommendation.likes = action.payload.likes;
        }
        
        // Update current recommendation if it's the one being liked
        if (state.currentRecommendation && state.currentRecommendation._id === action.payload.id) {
          state.currentRecommendation.likes = action.payload.likes;
        }
      });
  }
});

export const { 
  resetRecommendations, 
  setCategory,
  clearCurrentRecommendation
} = recommendationSlice.actions;
export default recommendationSlice.reducer;

// client/src/redux/slices/userSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import axios from 'axios';
import { RootState } from '../store';

interface RecommendationSummary {
  _id: string;
  title: string;
  createdAt: string;
  views: number;
  likes: number;
}

interface UserProfile {
  _id: string;
  username: string;
  profilePicture: string;
  bio: string;
  listeners: string[];
  listening: string[];
  badges: string[];
  recommendations: RecommendationSummary[];
  streak: number;
}

interface UserState {
  profile: UserProfile | null;
  isLoading: boolean;
  error: string | null;
}

const initialState: UserState = {
  profile: null,
  isLoading: false,
  error: null
};

// Get user profile
export const fetchUserProfile = createAsyncThunk<
  UserProfile,
  string,
  { state: RootState }
>(
  'user/fetchProfile',
  async (username, { getState, rejectWithValue }) => {
    try {
      const { auth } = getState();
      const config = auth.user 
        ? { headers: { Authorization: `Bearer ${auth.user.token}` } }
        : {};

      const { data } = await axios.get<UserProfile>(
        `/api/users/profile/${username}`,
        config
      );
      return data;
    } catch (error: any) {
      return rejectWithValue(
        error.response?.data?.message || 'Failed to fetch user profile'
      );
    }
  }
);

// Listen to a user
export const listenToUser = createAsyncThunk<
  { message: string },
  string,
  { state: RootState }
>(
  'user/listen',
  async (userId, { getState, rejectWithValue }) => {
    try {
      const { auth } = getState();
      
      if (!auth.user) {
        return rejectWithValue('Not authenticated');
      }

      const config = {
        headers: { 
          Authorization: `Bearer ${auth.user.token}`
        }
      };

      const { data } = await axios.post<{ message: string }>(
        `/api/users/listen/${userId}`,
        {},
        config
      );
      return data;
    } catch (error: any) {
      return rejectWithValue(
        error.response?.data?.message || 'Failed to listen to user'
      );
    }
  }
);

// Mute a user
export const muteUser = createAsyncThunk<
  { message: string },
  string,
  { state: RootState }
>(
  'user/mute',
  async (userId, { getState, rejectWithValue }) => {
    try {
      const { auth } = getState();
      
      if (!auth.user) {
        return rejectWithValue('Not authenticated');
      }

      const config = {
        headers: { 
          Authorization: `Bearer ${auth.user.token}`
        }
      };

      const { data } = await axios.post<{ message: string }>(
        `/api/users/mute/${userId}`,
        {},
        config
      );
      return data;
    } catch (error: any) {
      return rejectWithValue(
        error.response?.data?.message || 'Failed to mute user'
      );
    }
  }
);

const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    clearProfile: (state) => {
      state.profile = null;
    }
  },
  extraReducers: (builder) => {
    builder
      // Fetch profile cases
      .addCase(fetchUserProfile.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchUserProfile.fulfilled, (state, action: PayloadAction<UserProfile>) => {
        state.isLoading = false;
        state.profile = action.payload;
      })
      .addCase(fetchUserProfile.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
      // Listen to user cases - we'll need to refetch the profile after this
      .addCase(listenToUser.fulfilled, (state) => {
        // We'll handle this by fetching the updated profile
      })
      // Mute user cases - we'll need to refetch the profile after this
      .addCase(muteUser.fulfilled, (state) => {
        // We'll handle this by fetching the updated profile
      });
  }
});

export const { clearProfile } = userSlice.actions;
export default userSlice.reducer;

// client/src/redux/slices/notificationSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface Notification {
  id: string;
  message: string;
  type: 'success' | 'error' | 'info';
  timestamp: number;
}

interface NotificationState {
  notifications: Notification[];
  unreadCount: number;
}

const initialState: NotificationState = {
  notifications: [],
  unreadCount: 0
};

const notificationSlice = createSlice({
  name: 'notifications',
  initialState,
  reducers: {
    addNotification: (state, action: PayloadAction<Omit<Notification, 'id' | 'timestamp'>>) => {
      const id = Date.now().toString();
      state.notifications.unshift({
        ...action.payload,
        id,
        timestamp: Date.now()
      });
      state.unreadCount += 1;
    },
    removeNotification: (state, action: PayloadAction<string>) => {
      state.notifications = state.notifications.filter(
        (notification) => notification.id !== action.payload
      );
    },
    markAllAsRead: (state) => {
      state.unreadCount = 0;
    },
    clearNotifications: (state) => {
      state.notifications = [];
      state.unreadCount = 0;
    }
  }
});

export const {
  addNotification,
  removeNotification,
  markAllAsRead,
  clearNotifications
} = notificationSlice.actions;

export default notificationSlice.reducer;

// client/src/App.tsx
import React, { useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { useSelector, useDispatch } from 'react-redux';
import { RootState, AppDispatch } from './redux/store';
import { addNotification } from './redux/slices/notificationSlice';
import WebSocket from 'websocket';

// Layout components
import Layout from './components/Layout';

// Page components
import Home from './pages/Home';
import Login from './pages/Login';
import Register from './pages/Register';
import Profile from './pages/Profile';
import RecommendationDetail from './pages/RecommendationDetail';
import CreateRecommendation from './pages/CreateRecommendation';
import NotFound from './pages/NotFound';

// Private route component
import PrivateRoute from './components/PrivateRoute';

// WebSocket connection
let client: WebSocket.client | null = null;

const App: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { user } = useSelector((state: RootState) => state.auth);

  // Initialize WebSocket connection
  useEffect(() => {
    client = new WebSocket.client();

    client.on('connectFailed', (error) => {
      console.error('Connect Error:', error.toString());
    });

    client.on('connect', (connection) => {
      console.log('WebSocket Client Connected');

      connection.on('error', (error) => {
        console.error('Connection Error:', error.toString());
      });

      connection.on('close', () => {
        console.log('WebSocket Connection Closed');
      });

      connection.on('message', (message) => {
        if (message.type === 'utf8') {
          const data = JSON.parse(message.utf8Data);
          
          // Handle different message types
          if (data.type === 'notification') {
            dispatch(addNotification({
              message: data.message,
              type: data.notificationType
            }));
          }
        }
      });

      // Join feed room for real-time updates
      connection.send(JSON.stringify({ action: 'join-feed' }));

      // Join user room if logged in
      if (user) {
        connection.send(JSON.stringify({ 
          action: 'join-user',
          username: user.username 
        }));
      }
    });

    // Connect to WebSocket server
    client.connect(`${process.env.REACT_APP_WS_URL || 'ws://localhost:5000'}`);

    // Cleanup on unmount
    return () => {
      if (client && client.connection) {
        client.connection.close();
      }
    };
  }, [dispatch, user]);

  return (
    <Router>
      <Layout>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/login" element={<Login />} />
          <Route path="/register" element={<Register />} />
          <Route path="/profile/:username" element={<Profile />} />
          <Route path="/recommendations/:id" element={<RecommendationDetail />} />
          <Route 
            path="/create" 
            element={
              <PrivateRoute>
                <CreateRecommendation />
              </PrivateRoute>
            } 
          />
          <Route path="*" element={<NotFound />} />
        </Routes>
      </Layout>
    </Router>
  );
};

export default App;

// client/src/components/Layout.tsx
import React from 'react';
import { useSelector } from 'react-redux';
import { RootState } from '../redux/store';
import Header from './Header';
import Footer from './Footer';
import NotificationContainer from './NotificationContainer';
import QuickTips from './QuickTips';

interface LayoutProps {
  children: React.ReactNode;
}

const Layout: React.FC<LayoutProps> = ({ children }) => {
  const { user } = useSelector((state: RootState) => state.auth);
  const [showTips, setShowTips] = React.useState(true);

  return (
    <div className="flex flex-col min-h-screen">
      <Header />
      
      <main className

// client/src/types/index.ts
export interface User {
  id: string;
  name: string;
  bio: string | null;
  profilePic: string | null;
  listenersCount: number;
  listeningCount: number;
  createdAt: string;
  updatedAt: string;
}

export interface Recommendation {
  id: string;
  userId: string;
  text: string;
  audioUrl: string;
  category: string;
  sentiment: SentimentAnalysis;
  createdAt: string;
  user?: User;
}

export interface SentimentAnalysis {
  score: number;
  keywords: Array<{
    text: string;
    sentiment: number;
  }>;
  overall: 'positive' | 'negative' | 'neutral';
}

export interface AudioRecording {
  blob: Blob;
  url: string;
  duration: number;
}

export interface ApiError {
  message: string;
  status?: number;
  errors?: Record<string, string[]>;
}

export type Category = 
  | 'Food' 
  | 'Travel' 
  | 'Shopping' 
  | 'Experiences' 
  | 'Books' 
  | 'Movies' 
  | 'Music' 
  | 'Technology' 
  | 'Health & Wellness';

export type VoiceTone = 'Excited' | 'Calm' | 'Serious';

// client/src/api/client.ts
import axios, { AxiosError, AxiosRequestConfig } from 'axios';
import { ApiError } from '../types';

const API_URL = process.env.REACT_APP_API_URL || 'https://murmurs.app/api';

const apiClient = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 10000,
});

// Request interceptor for adding auth token
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('authToken');
    if (token && config.headers) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor for error handling
apiClient.interceptors.response.use(
  (response) => response,
  (error: AxiosError) => {
    const apiError: ApiError = {
      message: 'An unknown error occurred',
      status: error.response?.status,
    };

    if (error.response) {
      // The request was made and the server responded with a status code
      // that falls out of the range of 2xx
      apiError.message = error.response.data?.message || 'Server error';
      apiError.errors = error.response.data?.errors;
      
      // Handle authentication errors
      if (error.response.status === 401) {
        // Clear token and redirect to login
        localStorage.removeItem('authToken');
        window.location.href = '/login';
      }
    } else if (error.request) {
      // The request was made but no response was received
      apiError.message = 'No response from server. Please check your connection.';
    } else {
      // Something happened in setting up the request
      apiError.message = error.message;
    }

    return Promise.reject(apiError);
  }
);

export const get = async <T>(url: string, config?: AxiosRequestConfig): Promise<T> => {
  const response = await apiClient.get<T>(url, config);
  return response.data;
};

export const post = async <T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> => {
  const response = await apiClient.post<T>(url, data, config);
  return response.data;
};

export const put = async <T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> => {
  const response = await apiClient.put<T>(url, data, config);
  return response.data;
};

export const del = async <T>(url: string, config?: AxiosRequestConfig): Promise<T> => {
  const response = await apiClient.delete<T>(url, config);
  return response.data;
};

export default apiClient;

// client/src/api/recommendations.ts
import { get, post } from './client';
import { Recommendation } from '../types';

export const fetchRecommendations = async (
  category?: string, 
  searchQuery?: string, 
  page = 1, 
  limit = 10
): Promise<{ recommendations: Recommendation[], total: number }> => {
  return get<{ recommendations: Recommendation[], total: number }>('/recommendations', {
    params: { category, q: searchQuery, page, limit }
  });
};

export const fetchRecommendation = async (id: string): Promise<Recommendation> => {
  return get<Recommendation>(`/recommendations/${id}`);
};

export const createRecommendation = async (
  data: { 
    text: string; 
    category: string; 
    tone: string;
    audioBlob?: Blob;
  }
): Promise<Recommendation> => {
  const formData = new FormData();
  formData.append('text', data.text);
  formData.append('category', data.category);
  formData.append('tone', data.tone);
  
  if (data.audioBlob) {
    formData.append('audio', data.audioBlob, 'recording.webm');
  }

  return post<Recommendation>('/recommendations', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  });
};

// client/src/api/users.ts
import { get, post } from './client';
import { User, Recommendation } from '../types';

export const fetchUser = async (id: string): Promise<User> => {
  return get<User>(`/users/${id}`);
};

export const fetchUserRecommendations = async (
  userId: string,
  page = 1,
  limit = 10
): Promise<{ recommendations: Recommendation[], total: number }> => {
  return get<{ recommendations: Recommendation[], total: number }>(`/users/${userId}/recommendations`, {
    params: { page, limit }
  });
};

export const listenToUser = async (userId: string): Promise<{ message: string }> => {
  return post<{ message: string }>(`/users/${userId}/listen`);
};

export const muteUser = async (userId: string): Promise<{ message: string }> => {
  return post<{ message: string }>(`/users/${userId}/mute`);
};

export const updateProfile = async (
  data: {
    name?: string;
    bio?: string;
    profilePic?: File;
  }
): Promise<User> => {
  const formData = new FormData();
  if (data.name) formData.append('name', data.name);
  if (data.bio) formData.append('bio', data.bio);
  if (data.profilePic) formData.append('profilePic', data.profilePic);

  return post<User>('/users/profile', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  });
};

// client/src/api/auth.ts
import { post } from './client';

interface AuthResponse {
  token: string;
  user: {
    id: string;
    name: string;
    email: string;
  };
}

export const login = async (
  email: string,
  password: string
): Promise<AuthResponse> => {
  const response = await post<AuthResponse>('/auth/login', { email, password });
  // Store token in localStorage
  localStorage.setItem('authToken', response.token);
  return response;
};

export const register = async (
  name: string,
  email: string,
  password: string
): Promise<AuthResponse> => {
  const response = await post<AuthResponse>('/auth/register', { name, email, password });
  // Store token in localStorage
  localStorage.setItem('authToken', response.token);
  return response;
};

export const logout = (): void => {
  localStorage.removeItem('authToken');
};

// client/src/hooks/useAudioRecorder.ts
import { useState, useCallback, useRef, useEffect } from 'react';
import { AudioRecording } from '../types';

interface AudioRecorderHook {
  recording: boolean;
  audioURL: string | null;
  audioDuration: number;
  startRecording: () => Promise<void>;
  stopRecording: () => Promise<AudioRecording | null>;
  resetRecording: () => void;
  error: string | null;
}

export const useAudioRecorder = (maxDurationMs = 30000): AudioRecorderHook => {
  const [recording, setRecording] = useState<boolean>(false);
  const [audioURL, setAudioURL] = useState<string | null>(null);
  const [audioDuration, setAudioDuration] = useState<number>(0);
  const [error, setError] = useState<string | null>(null);
  
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const streamRef = useRef<MediaStream | null>(null);
  const chunksRef = useRef<BlobPart[]>([]);
  const startTimeRef = useRef<number>(0);
  const durationTimerRef = useRef<number | null>(null);
  const maxDurationTimerRef = useRef<number | null>(null);
  
  // Clean up function to stop all recording processes
  const cleanup = useCallback(() => {
    if (durationTimerRef.current) {
      window.clearInterval(durationTimerRef.current);
      durationTimerRef.current = null;
    }
    
    if (maxDurationTimerRef.current) {
      window.clearTimeout(maxDurationTimerRef.current);
      maxDurationTimerRef.current = null;
    }
    
    if (mediaRecorderRef.current && recording) {
      mediaRecorderRef.current.stop();
    }
    
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop());
      streamRef.current = null;
    }
    
    setRecording(false);
  }, [recording]);
  
  // Ensure cleanup on component unmount
  useEffect(() => {
    return () => {
      cleanup();
      
      // Also clean up any object URLs to prevent memory leaks
      if (audioURL) {
        URL.revokeObjectURL(audioURL);
      }
    };
  }, [cleanup, audioURL]);
  
  const startRecording = useCallback(async () => {
    try {
      // Reset any previous recordings
      resetRecording();
      
      // Request microphone access
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      streamRef.current = stream;
      
      // Set up MediaRecorder with the stream
      const mediaRecorder = new MediaRecorder(stream);
      mediaRecorderRef.current = mediaRecorder;
      
      // Set up event handlers
      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          chunksRef.current.push(event.data);
        }
      };
      
      // Start recording
      chunksRef.current = [];
      mediaRecorder.start(100); // Collect data every 100ms
      startTimeRef.current = Date.now();
      setRecording(true);
      
      // Set up timer for tracking duration
      durationTimerRef.current = window.setInterval(() => {
        const currentDuration = Date.now() - startTimeRef.current;
        setAudioDuration(currentDuration);
      }, 100);
      
      // Set up timer for maximum duration
      maxDurationTimerRef.current = window.setTimeout(() => {
        if (recording) {
          stopRecording();
        }
      }, maxDurationMs);
      
    } catch (err) {
      console.error('Error starting recording:', err);
      setError('Could not access the microphone. Please ensure it is connected and you have given permission.');
    }
  }, [maxDurationMs, recording, stopRecording]);
  
  const stopRecording = useCallback(async (): Promise<AudioRecording | null> => {
    if (!mediaRecorderRef.current || !recording) {
      return null;
    }
    
    return new Promise((resolve) => {
      if (mediaRecorderRef.current) {
        mediaRecorderRef.current.onstop = () => {
          const blob = new Blob(chunksRef.current, { type: 'audio/webm' });
          const url = URL.createObjectURL(blob);
          setAudioURL(url);
          const finalDuration = Date.now() - startTimeRef.current;
          setAudioDuration(finalDuration);
          
          // Clean up timers and streams
          if (durationTimerRef.current) {
            window.clearInterval(durationTimerRef.current);
            durationTimerRef.current = null;
          }
          
          if (maxDurationTimerRef.current) {
            window.clearTimeout(maxDurationTimerRef.current);
            maxDurationTimerRef.current = null;
          }
          
          if (streamRef.current) {
            streamRef.current.getTracks().forEach(track => track.stop());
            streamRef.current = null;
          }
          
          setRecording(false);
          
          resolve({
            blob,
            url,
            duration: finalDuration
          });
        };
        
        mediaRecorderRef.current.stop();
      } else {
        resolve(null);
      }
    });
  }, [recording]);
  
  const resetRecording = useCallback(() => {
    cleanup();
    
    if (audioURL) {
      URL.revokeObjectURL(audioURL);
    }
    
    setAudioURL(null);
    setAudioDuration(0);
    setError(null);
    chunksRef.current = [];
  }, [cleanup, audioURL]);
  
  return {
    recording,
    audioURL,
    audioDuration,
    startRecording,
    stopRecording,
    resetRecording,
    error
  };
};

// client/src/hooks/usePagination.ts
import { useState, useCallback } from 'react';

interface PaginationHook<T> {
  items: T[];
  loading: boolean;
  error: string | null;
  page: number;
  totalPages: number;
  hasMore: boolean;
  fetchPage: (newPage?: number) => Promise<void>;
  fetchNextPage: () => Promise<void>;
}

export function usePagination<T>(
  fetchFunction: (page: number, limit: number) => Promise<{ items: T[], total: number }>,
  limit = 10
): PaginationHook<T> {
  const [items, setItems] = useState<T[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [page, setPage] = useState(1);
  const [total, setTotal] = useState(0);

  const fetchPage = useCallback(async (newPage?: number) => {
    const pageToFetch = newPage !== undefined ? newPage : page;
    
    try {
      setLoading(true);
      setError(null);
      
      const result = await fetchFunction(pageToFetch, limit);
      
      setItems(result.items);
      setTotal(result.total);
      setPage(pageToFetch);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred while fetching data');
    } finally {
      setLoading(false);
    }
  }, [fetchFunction, limit, page]);

  const fetchNextPage = useCallback(async () => {
    if (page < Math.ceil(total / limit)) {
      await fetchPage(page + 1);
    }
  }, [fetchPage, page, total, limit]);

  const totalPages = Math.ceil(total / limit);
  const hasMore = page < totalPages;

  return {
    items,
    loading,
    error,
    page,
    totalPages,
    hasMore,
    fetchPage,
    fetchNextPage
  };
}

// client/src/App.tsx
import React, { useEffect, useState } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { Provider } from 'react-redux';
import { Toaster } from 'react-hot-toast';

import store from './store';
import HomePage from './pages/HomePage';
import RecordPage from './pages/RecordPage';
import ProfilePage from './pages/ProfilePage';
import LoginPage from './pages/LoginPage';
import RegisterPage from './pages/RegisterPage';
import RecommendationPage from './pages/RecommendationPage';
import NotFoundPage from './pages/NotFoundPage';
import MainLayout from './components/layout/MainLayout';
import LoadingScreen from './components/common/LoadingScreen';
import ProtectedRoute from './components/auth/ProtectedRoute';

import './App.css';

function App() {
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Simulate loading app resources
    const timer = setTimeout(() => {
      setIsLoading(false);
    }, 1500);

    return () => clearTimeout(timer);
  }, []);

  if (isLoading) {
    return <LoadingScreen />;
  }

  return (
    <Provider store={store}>
      <Router>
        <Toaster position="top-right" />
        <Routes>
          <Route path="/login" element={<LoginPage />} />
          <Route path="/register" element={<RegisterPage />} />
          
          <Route path="/" element={<MainLayout />}>
            <Route index element={<HomePage />} />
            <Route path="recommendations/:id" element={<RecommendationPage />} />
            <Route path="profile/:id" element={<ProfilePage />} />
            
            <Route path="record" element={
              <ProtectedRoute>
                <RecordPage />
              </ProtectedRoute>
            } />
          </Route>
          
          <Route path="/404" element={<NotFoundPage />} />
          <Route path="*" element={<Navigate to="/404" replace />} />
        </Routes>
      </Router>
    </Provider>
  );
}

export default App;

// client/src/components/common/AudioPlayer.tsx
import React, { useState, useEffect, useRef } from 'react';
import WaveSurfer from 'wavesurfer.js';

interface AudioPlayerProps {
  audioUrl: string;
  waveColor?: string;
  progressColor?: string;
  height?: number;
  barWidth?: number;
  barGap?: number;
  showControls?: boolean;
  className?: string;
}

const AudioPlayer: React.FC<AudioPlayerProps> = ({
  audioUrl,
  waveColor = '#ddd',
  progressColor = '#6366f1',
  height = 50,
  barWidth = 2,
  barGap = 1,
  showControls = true,
  className = '',
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const wavesurferRef = useRef<WaveSurfer | null>(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [duration, setDuration] = useState(0);
  const [currentTime, setCurrentTime] = useState(0);
  const [error, setError] = useState<string | null>(null);

  // Initialize wavesurfer
  useEffect(() => {
    if (!containerRef.current) return;

    setIsLoading(true);
    setError(null);

    try {
      const wavesurfer = WaveSurfer.create({
        container: containerRef.current,
        waveColor,
        progressColor,
        height,
        barWidth,
        barGap,
        responsive: true,
        cursorWidth: 0,
        normalize: true,
      });

      wavesurfer.on('ready', () => {
        wavesurferRef.current = wavesurfer;
        setIsLoading(false);
        setDuration(wavesurfer.getDuration());
      });

      wavesurfer.on('audioprocess', () => {
        if (wavesurfer) {
          setCurrentTime(wavesurfer.getCurrentTime());
        }
      });

      wavesurfer.on('play', () => setIsPlaying(true));
      wavesurfer.on('pause', () => setIsPlaying(false));
      wavesurfer.on('finish', () => setIsPlaying(false));

      wavesurfer.on('error', (err) => {
        console.error('WaveSurfer error:', err);
        setError('Could not load audio file');
        setIsLoading(false);
      });

      wavesurfer.load(audioUrl);

      return () => {
        wavesurfer.destroy();
      };
    } catch (err) {
      console.error('Error initializing WaveSurfer:', err);
      setError('Could not initialize audio player');
      setIsLoading(false);
    }
  }, [audioUrl, waveColor, progressColor, height, barWidth, barGap]);

  const togglePlayPause = () => {
    if (!wavesurferRef.current) return;

    if (isPlaying) {
      wavesurferRef.current.pause();
    } else {
      wavesurferRef.current.play();
    }
  };

  const formatTime = (timeInSeconds: number): string => {
    const minutes = Math.floor(timeInSeconds / 60);
    const seconds = Math.floor(timeInSeconds % 60);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  return (
    <div className={`audio-player ${className}`}>
      {isLoading && <div className="audio-loading">Loading audio...</div>}
      {error && <div className="audio-error">{error}</div>}

      <div ref={containerRef} className="waveform-container"></div>

      {showControls && (
        <div className="audio-controls">
          <button
            onClick={togglePlayPause}
            disabled={isLoading || !!error}
            aria-label={isPlaying ? 'Pause' : 'Play'}
            className="play-button"
          >
            {isPlaying ? '❚❚' : '▶'}
          </button>

          <div className="time-display">
            <span className="current-time">{formatTime(currentTime)}</span>
            <span className="duration"> / {formatTime(duration)}</span>
          </div>
        </div>
      )}
    </div>
  );
};

export default AudioPlayer;

// client/src/components/recommendations/RecommendationCard.tsx
import React from 'react';
import { Link } from 'react-router-dom';
import { Recommendation } from '../../types';
import AudioPlayer from '../common/AudioPlayer';

interface RecommendationCardProps {
  recommendation: Recommendation;
  onShare: (id: string) => void;
  onReaction: (id: string, reaction: 'like' | 'dislike') => void;
}

const RecommendationCard: React.FC<RecommendationCardProps> = ({
  recommendation,
  onShare,
  onReaction,
}) => {
  // Safely highlight sentiment keywords in text
  const renderHighlightedText = () => {
    if (!recommendation.sentiment?.keywords?.length) {
      return <p className="recommendation-text">{recommendation.text}</p>;
    }

    // Sort keywords by their position in the text to avoid overlap issues
    const sortedKeywords = [...recommendation.sentiment.keywords].sort((a, b) => {
      return recommendation.text.indexOf(a.text) - recommendation.text.indexOf(b.text);
    });

    let lastIndex = 0;
    const result = [];
    
    // Process each keyword
    for (const keyword of sortedKeywords) {
      const keywordIndex = recommendation.text.indexOf(keyword.text, lastIndex);
      
      // If keyword not found after last position, skip it
      if (keywordIndex === -1) continue;
      
      // Add text before keyword
      if (keywordIndex > lastIndex) {
        result.push(
          <React.Fragment key={`text-${lastIndex}`}>
            {recommendation.text.substring(lastIndex, keywordIndex)}
          </React.Fragment>
        );
      }
      
      // Add highlighted keyword
      const sentimentClass = keyword.sentiment > 0 
        ? 'positive-sentiment' 
        : keyword.sentiment < 0 
          ? 'negative-sentiment' 
          : 'neutral-sentiment';
          
      result.push(
        <span key={`keyword-${keywordIndex}`} className={sentimentClass}>
          {keyword.text}
        </span>
      );
      
      lastIndex = keywordIndex + keyword.text.length;
    }
    
    // Add any remaining text
    if (lastIndex < recommendation.text.length) {
      result.push(
        <React.Fragment key={`text-${lastIndex}`}>
          {recommendation.text.substring(lastIndex)}
        </React.Fragment>
      );
    }
    
    return <p className="recommendation-text">{result}</p>;
  };

  return (
    <div className="recommendation-card">
      <div className="recommendation-header">
        <Link to={`/profile/${recommendation.userId}`} className="user-info">
          <img 
            src={recommendation.user?.profilePic || '/assets/default-avatar.png'} 
            alt={recommendation.user?.name || 'User'} 
            className="user-avatar"
          />
          <div className="user-details">
            <h3 className="user-name">{recommendation.user?.name || 'Anonymous User'}</h3>
            <span className="recommendation-time">
              {new Date(recommendation.createdAt).toLocaleDateString()}
            </span>
          </div>
        </Link>
        <div className="recommendation-category">
          <span className="category-tag">{recommendation.category}</span>
        </div>
      </div>
      
      <div className="recommendation-content">
        {renderHighlightedText()}
        
        <div className="audio-section">
          <AudioPlayer 
            audioUrl={recommendation.audioUrl} 
            waveColor="#d1d5db"
            progressColor="#6366f1"
          />
        </div>
      </div>
      
      <div className="recommendation-actions">
        <div className="reaction-buttons">
          <button 
            className="reaction-button like-button" 
            onClick={() => onReaction(recommendation.id, 'like')}
            aria-label="Like"
          >
            <span className="reaction-icon">👍</span>
          </button>
          <button 
            className="reaction-button dislike-button" 
            onClick={() => onReaction(recommendation.id, 'dislike')}
            aria-label="Dislike"
          >
            <span className="reaction-icon">👎</span>
          </button>
        </div>
        
        <button 
          className="share-button" 
          onClick={() => onShare(recommendation.id)}
          aria-label="Share"
        >
          <span className="share-icon">🔗</span>
          <span className="share-text">Share</span>
        </button>
        
        <Link 
          to={`/recommendations/${recommendation.id}`} 
          className="view-button"
          aria-label="View details"
        >
          View details
        </Link>
      </div>
    </div>
  );
};

export default RecommendationCard;

// client/src/components/record/VoiceRecorder.tsx
import React, { useState, useEffect } from 'react';
import { useAudioRecorder } from '../../hooks/useAudioRecorder';
import { Category, VoiceTone, AudioRecording } from '../../types';
import toast from 'react-hot-toast';

interface VoiceRecorderProps {
  onRecordingComplete: (recording: AudioRecording) => void;
  maxDuration?: number; // in milliseconds
}

const VoiceRecorder: React.FC<VoiceRecorderProps> = ({
  onRecordingComplete,
  maxDuration = 30000, // Default 30 seconds
}) => {
  const {
    recording,
    audioURL,
    audioDuration,
    startRecording,
    stopRecording,
    resetRecording,
    error,
  } = useAudioRecorder(maxDuration);

  const [progress, setProgress] = useState(0);
  const [isHolding, setIsHolding] = useState(false);

  // Update progress bar based on recording duration
  useEffect

// client/src/components/record/VoiceRecorder.tsx
import React, { useState, useEffect } from 'react';
import { useAudioRecorder } from '../../hooks/useAudioRecorder';
import { Category, VoiceTone, AudioRecording } from '../../types';
import toast from 'react-hot-toast';

interface VoiceRecorderProps {
  onRecordingComplete: (recording: AudioRecording) => void;
  maxDuration?: number; // in milliseconds
}

const VoiceRecorder: React.FC<VoiceRecorderProps> = ({
  onRecordingComplete,
  maxDuration = 30000, // Default 30 seconds
}) => {
  const {
    recording,
    audioURL,
    audioDuration,
    startRecording,
    stopRecording,
    resetRecording,
    error,
  } = useAudioRecorder(maxDuration);

  const [progress, setProgress] = useState(0);
  const [isHolding, setIsHolding] = useState(false);

  // Update progress bar based on recording duration
  useEffect(() => {
    if (recording) {
      setProgress(Math.min((audioDuration / maxDuration) * 100, 100));
    }
  }, [audioDuration, maxDuration, recording]);

  // Handle errors from the audio recorder
  useEffect(() => {
    if (error) {
      toast.error(error);
    }
  }, [error]);

  const handleStartRecording = async () => {
    try {
      setIsHolding(true);
      await startRecording();
    } catch (err) {
      console.error('Failed to start recording:', err);
      toast.error('Could not start recording. Please check your microphone permissions.');
    }
  };

  const handleStopRecording = async () => {
    try {
      setIsHolding(false);
      const recording = await stopRecording();
      if (recording) {
        onRecordingComplete(recording);
      }
    } catch (err) {
      console.error('Failed to stop recording:', err);
      toast.error('An error occurred while saving your recording.');
    }
  };

  const handleReset = () => {
    resetRecording();
    setProgress(0);
  };

  const formatDuration = (ms: number): string => {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
  };

  return (
    <div className="voice-recorder">
      <div className="recorder-status">
        <div className="status-indicator">
          {recording && <span className="recording-pulse"></span>}
          <span className="status-text">
            {recording ? 'Recording...' : audioURL ? 'Recording complete' : 'Ready to record'}
          </span>
        </div>
        
        <div className="duration-display">
          {formatDuration(audioDuration)} / {formatDuration(maxDuration)}
        </div>
      </div>

      <div className="progress-bar-container">
        <div 
          className="progress-bar" 
          style={{ width: `${progress}%` }}
        ></div>
      </div>

      <div className="recorder-controls">
        {!audioURL ? (
          <button
            className={`record-button ${recording ? 'recording' : ''}`}
            onMouseDown={handleStartRecording}
            onMouseUp={handleStopRecording}
            onTouchStart={handleStartRecording}
            onTouchEnd={handleStopRecording}
            disabled={error !== null}
          >
            {recording ? 'Release to stop' : 'Hold to record'}
          </button>
        ) : (
          <div className="playback-controls">
            <audio src={audioURL} controls className="audio-playback"></audio>
            <button 
              className="reset-button"
              onClick={handleReset}
              aria-label="Reset recording"
            >
              Reset
            </button>
          </div>
        )}
      </div>

      {recording && (
        <p className="recording-tip">
          Speak clearly into your microphone. Recording will automatically stop after {maxDuration / 1000} seconds.
        </p>
      )}
    </div>
  );
};

export default VoiceRecorder;
// client/src/components/record/RecommendationForm.tsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Category, VoiceTone, AudioRecording } from '../../types';
import { createRecommendation } from '../../api/recommendations';
import VoiceRecorder from './VoiceRecorder';
import toast from 'react-hot-toast';

const CATEGORIES: Category[] = [
  'Food', 
  'Travel', 
  'Shopping', 
  'Experiences', 
  'Books', 
  'Movies', 
  'Music', 
  'Technology', 
  'Health & Wellness'
];

const VOICE_TONES: VoiceTone[] = ['Excited', 'Calm', 'Serious'];

const RecommendationForm: React.FC = () => {
  const navigate = useNavigate();
  const [text, setText] = useState('');
  const [category, setCategory] = useState<Category>('Experiences');
  const [tone, setTone] = useState<VoiceTone>('Excited');
  const [recording, setRecording] = useState<AudioRecording | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [step, setStep] = useState<'record' | 'details'>('record');
  
  const handleRecordingComplete = (newRecording: AudioRecording) => {
    setRecording(newRecording);
    setStep('details');
  };
  
  const handleTextChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setText(e.target.value);
  };
  
  const handleCategoryChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setCategory(e.target.value as Category);
  };
  
  const handleToneChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setTone(e.target.value as VoiceTone);
  };
  
  const handleGoBack = () => {
    setStep('record');
  };
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!recording) {
      toast.error('Please record audio before submitting');
      return;
    }
    
    if (!text.trim()) {
      toast.error('Please add a text description');
      return;
    }
    
    try {
      setIsSubmitting(true);
      
      const recommendationData = {
        text,
        category,
        tone,
        audioBlob: recording.blob
      };
      
      const result = await createRecommendation(recommendationData);
      
      toast.success('Recommendation published successfully!');
      navigate(`/recommendations/${result.id}`);
    } catch (error) {
      console.error('Error submitting recommendation:', error);
      toast.error('Failed to publish recommendation. Please try again.');
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <div className="recommendation-form">
      <h2 className="form-title">
        {step === 'record' ? 'Record Your Recommendation' : 'Finalize Your Recommendation'}
      </h2>
      
      {step === 'record' ? (
        <div className="recording-step">
          <p className="recording-instructions">
            Hold the record button and share your recommendation with the world.
            Try to be clear and concise, focusing on what you loved (or didn't).
          </p>
          
          <VoiceRecorder 
            onRecordingComplete={handleRecordingComplete}
            maxDuration={60000} // 1 minute max
          />
        </div>
      ) : (
        <form onSubmit={handleSubmit} className="details-form">
          <div className="form-group">
            <label htmlFor="recommendation-text">What's your recommendation?</label>
            <textarea
              id="recommendation-text"
              value={text}
              onChange={handleTextChange}
              placeholder="Describe what you're recommending and why..."
              rows={4}
              required
              className="text-input"
            />
          </div>
          
          <div className="form-group">
            <label htmlFor="category-select">Category</label>
            <select
              id="category-select"
              value={category}
              onChange={handleCategoryChange}
              className="category-select"
              required
            >
              {CATEGORIES.map((cat) => (
                <option key={cat} value={cat}>
                  {cat}
                </option>
              ))}
            </select>
          </div>
          
          <div className="form-group">
            <label htmlFor="tone-select">Voice Tone</label>
            <select
              id="tone-select"
              value={tone}
              onChange={handleToneChange}
              className="tone-select"
              required
            >
              {VOICE_TONES.map((t) => (
                <option key={t} value={t}>
                  {t}
                </option>
              ))}
            </select>
          </div>
          
          {recording && (
            <div className="recording-preview">
              <h3>Your Recording</h3>
              <audio src={recording.url} controls className="audio-preview" />
              <p className="recording-duration">
                Duration: {Math.round(recording.duration / 1000)} seconds
              </p>
            </div>
          )}
          
          <div className="form-actions">
            <button
              type="button"
              onClick={handleGoBack}
              className="back-button"
              disabled={isSubmitting}
            >
              Re-record
            </button>
            
            <button
              type="submit"
              className="submit-button"
              disabled={isSubmitting || !recording || !text.trim()}
            >
              {isSubmitting ? 'Publishing...' : 'Publish Recommendation'}
            </button>
          </div>
        </form>
      )}
    </div>
  );
};

export default RecommendationForm;

// client/src/pages/RecordPage.tsx
import React from 'react';
import { Helmet } from 'react-helmet';
import RecommendationForm from '../components/record/RecommendationForm';

const RecordPage: React.FC = () => {
  return (
    <div className="record-page">
      <Helmet>
        <title>Create a Recommendation | Murmur</title>
        <meta name="description" content="Share your voice recommendation with the world" />
      </Helmet>
      
      <div className="page-header">
        <h1>Share Your Recommendation</h1>
        <p className="page-description">
          Record your voice and share your honest opinion about products, places, or experiences.
        </p>
      </div>
      
      <div className="content-container">
        <RecommendationForm />
        
        <div className="recording-tips">
          <h3>Tips for a Great Recommendation</h3>
          <ul>
            <li>
              <strong>Be specific:</strong> Share details about what you're recommending
            </li>
            <li>
              <strong>Be authentic:</strong> Your honest opinion matters most
            </li>
            <li>
              <strong>Be concise:</strong> Keep your recommendation under 60 seconds
            </li>
            <li>
              <strong>Good audio:</strong> Find a quiet space to record
            </li>
          </ul>
        </div>
      </div>
    </div>
  );
};

export default RecordPage;

// client/src/components/recommendations/RecommendationFeed.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { Recommendation, Category } from '../../types';
import { fetchRecommendations } from '../../api/recommendations';
import RecommendationCard from './RecommendationCard';
import toast from 'react-hot-toast';

interface RecommendationFeedProps {
  initialCategory?: Category | null;
}

const RecommendationFeed: React.FC<RecommendationFeedProps> = ({ 
  initialCategory = null 
}) => {
  const [recommendations, setRecommendations] = useState<Recommendation[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedCategory, setSelectedCategory] = useState<Category | null>(initialCategory);
  const [searchQuery, setSearchQuery] = useState('');
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const [totalCount, setTotalCount] = useState(0);

  const CATEGORIES: Category[] = [
    'Food', 
    'Travel', 
    'Shopping', 
    'Experiences', 
    'Books', 
    'Movies', 
    'Music', 
    'Technology', 
    'Health & Wellness'
  ];

  // Fetch recommendations based on current filters
  const loadRecommendations = useCallback(async (reset = false) => {
    try {
      setLoading(true);
      setError(null);
      
      const currentPage = reset ? 1 : page;
      const result = await fetchRecommendations(
        selectedCategory || undefined,
        searchQuery || undefined,
        currentPage,
        10 // limit per page
      );
      
      if (reset) {
        setRecommendations(result.recommendations);
      } else {
        setRecommendations(prev => [...prev, ...result.recommendations]);
      }
      
      setTotalCount(result.total);
      setHasMore(result.recommendations.length === 10);
      
      if (reset) {
        setPage(1);
      } else {
        setPage(currentPage + 1);
      }
    } catch (err) {
      console.error('Error fetching recommendations:', err);
      setError('Failed to load recommendations. Please try again.');
    } finally {
      setLoading(false);
    }
  }, [selectedCategory, searchQuery, page]);

  // Initial load
  useEffect(() => {
    loadRecommendations(true);
  }, [selectedCategory, searchQuery]);

  // Handle category filter change
  const handleCategoryChange = (category: Category | null) => {
    if (category === selectedCategory) {
      setSelectedCategory(null);
    } else {
      setSelectedCategory(category);
    }
  };

  // Handle search input
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchQuery(e.target.value);
  };

  // Handle search form submission
  const handleSearchSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    loadRecommendations(true);
  };

  // Load more recommendations
  const handleLoadMore = () => {
    if (!loading && hasMore) {
      loadRecommendations();
    }
  };

  // Handle sharing a recommendation
  const handleShare = (id: string) => {
    const shareUrl = `${window.location.origin}/recommendations/${id}`;
    
    if (navigator.share) {
      navigator.share({
        title: 'Check out this recommendation on Murmur!',
        url: shareUrl
      }).catch(err => {
        console.error('Error sharing:', err);
      });
    } else {
      // Fallback to clipboard copy
      navigator.clipboard.writeText(shareUrl).then(() => {
        toast.success('Link copied to clipboard!');
      }).catch(err => {
        console.error('Error copying to clipboard:', err);
        toast.error('Failed to copy link. Please try again.');
      });
    }
  };

  // Handle reactions (like/dislike)
  const handleReaction = (id: string, reaction: 'like' | 'dislike') => {
    // This would typically call an API endpoint to record the reaction
    // For the MVP, we'll just show a toast
    toast.success(`You ${reaction}d this recommendation!`);
  };

  return (
    <div className="recommendation-feed">
      <div className="feed-filters">
        <div className="category-filters">
          {CATEGORIES.map(category => (
            <button
              key={category}
              className={`category-filter ${selectedCategory === category ? 'active' : ''}`}
              onClick={() => handleCategoryChange(category)}
            >
              {category}
            </button>
          ))}
          {selectedCategory && (
            <button 
              className="clear-filter"
              onClick={() => setSelectedCategory(null)}
            >
              Clear filter
            </button>
          )}
        </div>
        
        <form onSubmit={handleSearchSubmit} className="search-form">
          <input
            type="text"
            value={searchQuery}
            onChange={handleSearchChange}
            placeholder="Search recommendations..."
            className="search-input"
          />
          <button type="submit" className="search-button">
            Search
          </button>
        </form>
      </div>
      
      {loading && page === 1 && (
        <div className="loading-state">
          <div className="spinner"></div>
          <p>Loading recommendations...</p>
        </div>
      )}
      
      {error && (
        <div className="error-state">
          <p>{error}</p>
          <button onClick={() => loadRecommendations(true)}>Retry</button>
        </div>
      )}
      
      {!loading && !error && recommendations.length === 0 && (
        <div className="empty-state">
          <h3>No recommendations found</h3>
          <p>
            {selectedCategory || searchQuery
              ? 'Try adjusting your filters or search query'
              : 'Be the first to share a recommendation!'}
          </p>
        </div>
      )}
      
      <div className="recommendations-list">
        {recommendations.map(recommendation => (
          <RecommendationCard
            key={recommendation.id}
            recommendation={recommendation}
            onShare={handleShare}
            onReaction={handleReaction}
          />
        ))}
      </div>
      
      {!loading && hasMore && (
        <div className="load-more">
          <button 
            onClick={handleLoadMore}
            className="load-more-button"
          >
            Load More
          </button>
        </div>
      )}
      
      {loading && page > 1 && (
        <div className="loading-more">
          <div className="spinner-small"></div>
          <p>Loading more...</p>
        </div>
      )}
      
      {!loading && recommendations.length > 0 && (
        <div className="feed-stats">
          Showing {recommendations.length} of {totalCount} recommendations
        </div>
      )}
    </div>
  );
};

export default RecommendationFeed;

// client/src/pages/HomePage.tsx
import React from 'react';
import { Helmet } from 'react-helmet';
import { Link } from 'react-router-dom';
import RecommendationFeed from '../components/recommendations/RecommendationFeed';

const HomePage: React.FC = () => {
  const isAuthenticated = !!localStorage.getItem('authToken');

  return (
    <div className="home-page">
      <Helmet>
        <title>Murmur - Voice Recommendations</title>
        <meta name="description" content="Discover voice-based recommendations from real people" />
      </Helmet>

      <div className="hero-section">
        <div className="hero-content">
          <h1 className="hero-title">Hear authentic recommendations</h1>
          <p className="hero-subtitle">
            Real voices. Real opinions. Discover products, places, and experiences
            recommended by real people.
          </p>
          
          {isAuthenticated ? (
            <Link to="/record" className="cta-button">
              Share Your Recommendation
            </Link>
          ) : (
            <div className="auth-cta">
              <Link to="/login" className="login-button">
                Log In
              </Link>
              <Link to="/register" className="register-button">
                Sign Up
              </Link>
            </div>
          )}
        </div>
      </div>

      <div className="popular-categories">
        <h2>Popular Categories</h2>
        <div className="categories-grid">
          {['Food', 'Travel', 'Books', 'Technology'].map(category => (
            <div key={category} className="category-card">
              <h3>{category}</h3>
              <p>Discover {category.toLowerCase()} recommendations</p>
            </div>
          ))}
        </div>
      </div>

      <div className="main-content">
        <h2>Latest Recommendations</h2>
        <RecommendationFeed />
      </div>

      <div className="app-download">
        <div className="download-content">
          <h2>Take Murmur with you</h2>
          <p>Download our mobile app and discover recommendations on the go.</p>
          <div className="download-buttons">
            <a href="#" className="app-store-button">App Store</a>
            <a href="#" className="play-store-button">Google Play</a>
          </div>
        </div>
      </div>
    </div>
  );
};

export default HomePage;

// client/src/pages/ProfilePage.tsx
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Helmet } from 'react-helmet';
import { fetchUser, fetchUserRecommendations, listenToUser, muteUser } from '../api/users';
import { User, Recommendation } from '../types';
import RecommendationCard from '../components/recommendations/RecommendationCard';
import toast from 'react-hot-toast';

const ProfilePage: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const [user, setUser] = useState<User | null>(null);
  const [recommendations, setRecommendations] = useState<Recommendation[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const [isListening, setIsListening] = useState(false);
  
  // Get the current user ID from localStorage
  const currentUserId = localStorage.getItem('userId');
  const isOwnProfile = currentUserId === id;

  // Fetch user profile and initial recommendations
  useEffect(() => {
    const loadProfile = async () => {
      if (!id) return;
      
      try {
        setLoading(true);
        setError(null);
        
        // Fetch user profile
        const userData = await fetchUser(id);
        setUser(userData);
        
        // Check if current user is listening to this profile
        setIsListening(userData.listenersCount > 0); // This is a simplification; would need a proper endpoint
        
        // Fetch user's recommendations
        const result = await fetchUserRecommendations(id, 1, 5);
        setRecommendations(result.recommendations);
        setHasMore(result.recommendations.length === 5);
        
      } catch (err) {
        console.error('Error loading profile:', err);
        setError('Failed to load user profile. The user may not exist or has been removed.');
      } finally {
        setLoading(false);
      }
    };
    
    loadProfile();
  }, [id]);

  // Load more recommendations
  const loadMoreRecommendations = async () => {
    if (!id || !hasMore || loading) return;
    
    try {
      setLoading(true);
      const nextPage = page + 1;
      const result = await fetchUserRecommendations(id, nextPage, 5);
      
      if (result.recommendations.length > 0) {
        setRecommendations(prev => [...prev, ...result.recommendations]);
        setPage(nextPage);
      }
      
      setHasMore(result.recommendations.length === 5);
    } catch (err) {
      console.error('Error loading more recommendations:', err);
      toast.error('Failed to load more recommendations');
    } finally {
      setLoading(false);
    }
  };

  // Handle listen/unfollow functionality
  const handleListenToggle = async () => {
    if (!id || !user) return;
    
    try {
      if (isListening) {
        await muteUser(id);
        setIsListening(false);
        toast.success(`You are no longer listening to ${user.name}`);
      } else {
        await listenToUser(id);
        setIsListening(true);
        toast.success(`You are now listening to ${user.name}`);
      }
      
      // Update the user object with the new count
      setUser(prev => {
        if (!prev) return prev;
        return {
          ...prev,
          listenersCount: isListening 
            ? Math.max(0, prev.listenersCount - 1)
            : prev.listenersCount + 1
        };
      });
    } catch (err) {
      console.error('Error toggling listen status:', err);
      toast.error('Failed to update listening status');
    }
  };

  // Handle sharing a recommendation
  const handleShare = (recommendationId: string) => {
    const shareUrl = `${window.location.origin}/recommendations/${recommendationId}`;
    
    if (navigator.share) {
      navigator.share({
        title: `Check out this recommendation by ${user?.name}`,
        url: shareUrl
      }).catch(err => {
        console.error('Error sharing:', err);
      });
    } else {
      // Fallback to clipboard copy
      navigator.clipboard.writeText(shareUrl).then(() => {
        toast.success('Link copied to clipboard!');
      }).catch(err => {
        console.error('Error copying to clipboard:', err);
        toast.error('Failed to copy link');
      });
    }
  };

  // Handle reactions (like/dislike)
  const handleReaction = (id: string, reaction: 'like' | 'dislike') => {
    // This would typically call an API endpoint to record the reaction
    toast.success(`You ${reaction}d this recommendation!`);
  };

  // Handle sharing the profile
  const handleShareProfile = () => {
    if (!user) return;
    
    const profileUrl = `${window.location.origin}/profile/${id}`;
    
    if (navigator.share) {
      navigator.share({
        title: `Check out ${user.name} on Murmur`,
        url: profileUrl
      }).catch(err => {
        console.error('Error sharing:', err);
      });
    } else {
      // Fallback to clipboard copy
      navigator.clipboard.writeText(profileUrl).then(() => {
        toast.success('Profile link copied to clipboard!');
      }).catch(err => {
        console.error('Error copying to clipboard:', err);
        toast.error('Failed to copy profile link');
      });
    }
  };

  if (error) {
    return (
      <div className="error-container">
        <h2>Error</h2>
        <p>{error}</p>
        <button onClick={() => navigate('/')} className="back-button">
          Go to Homepage
        </button>
      </div>
    );
  }

  if (loading && !user) {
    return (
      <div className="loading-container">
        <div className="spinner"></div>
        <p>Loading profile...</p>
      </div>
    );
  }

  if (!user) {
    return null;
  }

  return (
    <div className="profile-page">
      <Helmet>
        <title>{user.name} | Murmur</title>
        <meta name="description" content={`Check out ${user.name}'s recommendations on Murmur`} />
      </Helmet>

      <div className="profile-header">
        <div className="profile-cover-photo"></div>
        
        <div className="profile-info">
          <div className="profile-avatar">
            <img 
              src={user.profilePic || '/assets/default-avatar.png'} 
              alt={user.name} 
              className="avatar-image"
            />
          </div>
          
          <div className="profile-details">
            <h1 className="profile-name">{user.name}</h1>
            
            <p className="profile-bio">
              {user.bio || 'No bio available'}
            </p>
            
            <div className="profile-stats">
              <div className="stat">
                <span className="stat-value">{user.listenersCount}</span>
                <span className="stat-label">Listeners</span>
              </div>
              <div className="stat">
                <span className="stat-value">{user.listeningCount}</span>
                <span className="stat-label">Listening</span>
              </div>
              <div className="stat">
                <span className="stat-value">{recommendations.length}</span>
                <span className="stat-label">Recommendations</span>
              </div>
            </div>
            
            <div className="profile-actions">
              {!isOwnProfile && (
                <button 
                  className={`listen-button ${isListening ? 'listening' : ''}`}
                  onClick={handleListenToggle}
                >
                  {isListening ? 'Listening' : 'Listen'}
                </button>
              )}
              
              {isOwnProfile && (
                <button 
                  className="edit-profile-button"
                  onClick={() => navigate('/settings/profile')}
                >
                  Edit Profile
                </button>
              )}
              
              <button 
                className="share-profile-

import argparse
import os
import sys
import uuid
from datetime import datetime
import json
import readline  # For better input handling

# Assuming the Conversation, save_conversation, get_conversation, etc. are defined as shown in the claude.murmur.MVP file

class MurmurCLI:
    def __init__(self):
        self.current_conversation = None
        self.llm = None
        self.config = self._load_config()
    
    def _load_config(self):
        """Load configuration from file or environment variables"""
        config = {
            "anthropic_api_key": os.environ.get("ANTHROPIC_API_KEY", ""),
            "openai_api_key": os.environ.get("OPENAI_API_KEY", ""),
            "default_model": os.environ.get("MURMUR_DEFAULT_MODEL", "claude-3-opus-20240229"),
            "history_dir": os.path.expanduser("~/.murmur/history")
        }
        
        config_path = os.path.expanduser("~/.murmur/config.json")
        if os.path.exists(config_path):
            try:
                with open(config_path, 'r') as f:
                    file_config = json.load(f)
                    config.update(file_config)
            except Exception as e:
                print(f"Error loading config: {e}")
        
        return config
    
    def _save_config(self):
        """Save current configuration to file"""
        config_path = os.path.expanduser("~/.murmur/config.json")
        os.makedirs(os.path.dirname(config_path), exist_ok=True)
        
        with open(config_path, 'w') as f:
            json.dump(self.config, f, indent=2)
    
    def _init_llm(self, model=None):
        """Initialize the appropriate LLM client based on model"""
        if not model:
            model = self.config["default_model"]
        
        if "claude" in model.lower():
            if not self.config.get("anthropic_api_key"):
                print("Error: Anthropic API key not set. Please run 'murmur config --anthropic-key YOUR_KEY'")
                sys.exit(1)
            self.llm = ClaudeLLM(api_key=self.config["anthropic_api_key"], model=model)
        elif "gpt" in model.lower():
            if not self.config.get("openai_api_key"):
                print("Error: OpenAI API key not set. Please run 'murmur config --openai-key YOUR_KEY'")
                sys.exit(1)
            # Implement OpenAI LLM class similar to ClaudeLLM
            self.llm = OpenAILLM(api_key=self.config["openai_api_key"], model=model)
        else:
            print(f"Unsupported model: {model}")
            sys.exit(1)
        
        return self.llm
    
    def create_conversation(self, title=None, system_prompt=None, model=None):
        """Create a new conversation"""
        if not title:
            title = f"Conversation {datetime.now().strftime('%Y-%m-%d %H:%M')}"
        
        if not system_prompt:
            system_prompt = "You are Claude, an AI assistant created by Anthropic to be helpful, harmless, and honest."
        
        if not model:
            model = self.config["default_model"]
        
        self.current_conversation = Conversation(
            id=str(uuid.uuid4()),
            title=title,
            system_prompt=system_prompt,
            messages=[],
            model=model,
            created_at=generate_timestamp(),
            updated_at=generate_timestamp()
        )
        
        save_conversation(self.current_conversation)
        self._init_llm(model)
        
        print(f"Created new conversation: {title}")
        return self.current_conversation
    
    def list_conversations(self):
        """List all available conversations"""
        conversations = get_conversations()
        
        if not conversations:
            print("No conversations found.")
            return
        
        print("\nAvailable conversations:")
        print("-----------------------")
        for idx, conv in enumerate(conversations, 1):
            print(f"{idx}. {conv.title} (ID: {conv.id[:8]}...)")
            print(f"   Created: {conv.created_at}")
            print(f"   Model: {conv.model}")
            print(f"   Messages: {len(conv.messages)}")
            print()
        
        return conversations
    
    def load_conversation(self, conversation_id):
        """Load an existing conversation"""
        try:
            conversation = get_conversation(conversation_id)
            self.current_conversation = conversation
            self._init_llm(conversation.model)
            print(f"Loaded conversation: {conversation.title}")
            return conversation
        except Exception as e:
            print(f"Error loading conversation: {e}")
            return None
    
    def send_message(self, message):
        """Send a message to the current conversation and get a response"""
        if not self.current_conversation:
            print("No active conversation. Create or load a conversation first.")
            return
        
        if not self.llm:
            self._init_llm(self.current_conversation.model)
        
        try:
            # Add user message to conversation
            self.current_conversation.messages.append({
                "role": "user",
                "content": message,
                "timestamp": generate_timestamp()
            })
            
            # Get response from LLM
            response = self.llm.generate_response(self.current_conversation, message)
            
            # Add assistant response to conversation
            self.current_conversation.messages.append({
                "role": "assistant",
                "content": response,
                "timestamp": generate_timestamp()
            })
            
            # Update and save conversation
            self.current_conversation.updated_at = generate_timestamp()
            save_conversation(self.current_conversation)
            
            # Display the response
            print("\n" + response + "\n")
            
        except Exception as e:
            print(f"Error: {e}")
    
    def interactive_mode(self):
        """Start an interactive session with the current conversation"""
        if not self.current_conversation:
            print("No active conversation. Creating a new one...")
            self.create_conversation()
        
        print(f"\nInteractive mode - {self.current_conversation.title}")
        print(f"Model: {self.current_conversation.model}")
        print("Type 'exit', 'quit', or press Ctrl+C to end the session")
        print("Type '/help' for more commands")
        print("-" * 50)
        
        while True:
            try:
                user_input = input("\n> ")
                
                if user_input.lower() in ["exit", "quit"]:
                    break
                
                # Handle special commands
                if user_input.startswith("/"):
                    self._handle_command(user_input)
                    continue
                
                # Process regular message
                self.send_message(user_input)
                
            except KeyboardInterrupt:
                print("\nExiting interactive mode...")
                break
            except Exception as e:
                print(f"Error: {e}")
    
    def _handle_command(self, command):
        """Handle special commands in interactive mode"""
        cmd = command.strip().lower()
        
        if cmd == "/help":
            print("\nAvailable commands:")
            print("  /help           - Show this help message")
            print("  /new            - Create a new conversation")
            print("  /list           - List available conversations")
            print("  /load <id>      - Load a conversation by ID")
            print("  /title <text>   - Set conversation title")
            print("  /system <text>  - Set system prompt")
            print("  /model <model>  - Change the model")
            print("  /history        - Show conversation history")
            print("  exit or quit    - Exit interactive mode")
        
        elif cmd == "/new":
            title = input("Title (optional): ")
            system = input("System prompt (optional): ")
            model = input(f"Model (default: {self.config['default_model']}): ")
            
            self.create_conversation(
                title=title if title else None,
                system_prompt=system if system else None,
                model=model if model else None
            )
        
        elif cmd == "/list":
            self.list_conversations()
        
        elif cmd.startswith("/load "):
            conv_id = cmd.split("/load ")[1].strip()
            self.load_conversation(conv_id)
        
        elif cmd.startswith("/title "):
            new_title = cmd.split("/title ")[1].strip()
            if self.current_conversation:
                self.current_conversation.title = new_title
                save_conversation(self.current_conversation)
                print(f"Title updated: {new_title}")
        
        elif cmd.startswith("/system "):
            new_system = cmd.split("/system ")[1].strip()
            if self.current_conversation:
                self.current_conversation.system_prompt = new_system
                save_conversation(self.current_conversation)
                print("System prompt updated")
        
        elif cmd.startswith("/model "):
            new_model = cmd.split("/model ")[1].strip()
            if self.current_conversation:
                self.current_conversation.model = new_model
                self._init_llm(new_model)
                save_conversation(self.current_conversation)
                print(f"Model changed to {new_model}")
        
        elif cmd == "/history":
            if self.current_conversation and self.current_conversation.messages:
                for msg in self.current_conversation.messages:
                    role = msg["role"].upper()
                    print(f"\n[{role}]: {msg['content']}")
            else:
                print("No messages in current conversation")
        
        else:
            print(f"Unknown command: {command}. Type /help for available commands.")

    def configure(self, anthropic_key=None, openai_key=None, default_model=None):
        """Update configuration settings"""
        if anthropic_key:
            self.config["anthropic_api_key"] = anthropic_key
        
        if openai_key:
            self.config["openai_api_key"] = openai_key
        
        if default_model:
            self.config["default_model"] = default_model
        
        self._save_config()
        print("Configuration updated")


def main():
    """Main entry point for the Murmur CLI"""
    parser = argparse.ArgumentParser(description="Murmur - A CLI for conversations with LLMs")
    subparsers = parser.add_subparsers(dest="command", help="Command to run")
    
    # New conversation command
    new_parser = subparsers.add_parser("new", help="Create a new conversation")
    new_parser.add_argument("--title", "-t", help="Title for the conversation")
    new_parser.add_argument("--system", "-s", help="System prompt for the conversation")
    new_parser.add_argument("--model", "-m", help="Model to use")
    
    # List conversations command
    subparsers.add_parser("list", help="List available conversations")
    
    # Load conversation command
    load_parser = subparsers.add_parser("load", help="Load an existing conversation")
    load_parser.add_argument("id", help="ID of the conversation to load")
    
    # Send message command
    send_parser = subparsers.add_parser("send", help="Send a message to a conversation")
    send_parser.add_argument("--id", help="ID of the conversation to use")
    send_parser.add_argument("message", nargs="?", help="Message to send")
    
    # Interactive mode command
    interactive_parser = subparsers.add_parser("chat", help="Start interactive chat mode")
    interactive_parser.add_argument("--id", help="ID of the conversation to use")
    
    # Configuration command
    config_parser = subparsers.add_parser("config", help="Update configuration settings")
    config_parser.add_argument("--anthropic-key", help="Set Anthropic API key")
    config_parser.add_argument("--openai-key", help="Set OpenAI API key")
    config_parser.add_argument("--default-model", help="Set default model")
    
    args = parser.parse_args()
    
    # Initialize CLI
    cli = MurmurCLI()
    
    # Process commands
    if args.command == "new":
        cli.create_conversation(
            title=args.title,
            system_prompt=args.system,
            model=args.model
        )
    
    elif args.command == "list":
        cli.list_conversations()
    
    elif args.command == "load":
        cli.load_conversation(args.id)
    
    elif args.command == "send":
        if args.id:
            cli.load_conversation(args.id)
        
        if not cli.current_conversation:
            print("No active conversation. Use --id to specify a conversation.")
            sys.exit(1)
        
        if args.message:
            cli.send_message(args.message)
        else:
            # Read from stdin if no message provided
            message = sys.stdin.read().strip()
            if message:
                cli.send_message(message)
    
    elif args.command == "chat":
        if args.id:
            cli.load_conversation(args.id)
        
        cli.interactive_mode()
    
    elif args.command == "config":
        cli.configure(
            anthropic_key=args.anthropic_key,
            openai_key=args.openai_key,
            default_model=args.default_model
        )
    
    else:
        # Default to interactive mode if no command specified
        cli.interactive_mode()


if __name__ == "__main__":
    main()

// src/components/Layout.jsx
import React from 'react';
import { Link, useLocation } from 'react-router-dom';
import { Home, User, Bell, MessageSquare, Settings, LogOut } from 'lucide-react';

const Layout = ({ children }) => {
  const location = useLocation();
  
  const isActive = (path) => {
    return location.pathname === path;
  };

  return (
    <div className="flex min-h-screen bg-gray-100">
      {/* Sidebar */}
      <aside className="w-16 md:w-64 bg-white shadow-md">
        <div className="h-16 flex items-center justify-center md:justify-start px-4 border-b">
          <Link to="/" className="font-bold text-xl text-blue-600">
            <span className="hidden md:inline">Murmur</span>
            <span className="md:hidden">M</span>
          </Link>
        </div>
        <nav className="p-2">
          <ul className="space-y-2">
            <li>
              <Link 
                to="/" 
                className={`flex items-center p-2 rounded-lg ${
                  isActive('/') 
                    ? 'bg-blue-100 text-blue-600' 
                    : 'text-gray-700 hover:bg-gray-100'
                }`}
              >
                <Home className="h-5 w-5" />
                <span className="hidden md:inline ml-3">Home</span>
              </Link>
            </li>
            <li>
              <Link 
                to="/profile" 
                className={`flex items-center p-2 rounded-lg ${
                  isActive('/profile') 
                    ? 'bg-blue-100 text-blue-600' 
                    : 'text-gray-700 hover:bg-gray-100'
                }`}
              >
                <User className="h-5 w-5" />
                <span className="hidden md:inline ml-3">Profile</span>
              </Link>
            </li>
            <li>
              <Link 
                to="/notifications" 
                className={`flex items-center p-2 rounded-lg ${
                  isActive('/notifications') 
                    ? 'bg-blue-100 text-blue-600' 
                    : 'text-gray-700 hover:bg-gray-100'
                }`}
              >
                <Bell className="h-5 w-5" />
                <span className="hidden md:inline ml-3">Notifications</span>
              </Link>
            </li>
            <li>
              <Link 
                to="/messages" 
                className={`flex items-center p-2 rounded-lg ${
                  isActive('/messages') 
                    ? 'bg-blue-100 text-blue-600' 
                    : 'text-gray-700 hover:bg-gray-100'
                }`}
              >
                <MessageSquare className="h-5 w-5" />
                <span className="hidden md:inline ml-3">Messages</span>
              </Link>
            </li>
            <li>
              <Link 
                to="/settings" 
                className={`flex items-center p-2 rounded-lg ${
                  isActive('/settings') 
                    ? 'bg-blue-100 text-blue-600' 
                    : 'text-gray-700 hover:bg-gray-100'
                }`}
              >
                <Settings className="h-5 w-5" />
                <span className="hidden md:inline ml-3">Settings</span>
              </Link>
            </li>
          </ul>
        </nav>
        <div className="absolute bottom-0 w-16 md:w-64 p-4 border-t">
          <button className="flex items-center w-full p-2 rounded-lg text-gray-700 hover:bg-gray-100">
            <LogOut className="h-5 w-5" />
            <span className="hidden md:inline ml-3">Logout</span>
          </button>
        </div>
      </aside>

      {/* Main content */}
      <main className="flex-1">
        <header className="h-16 bg-white shadow-sm flex items-center px-4">
          <div className="max-w-7xl w-full mx-auto">
            <h1 className="text-lg font-semibold text-gray-900">
              {location.pathname === '/' && 'Home'}
              {location.pathname === '/profile' && 'Profile'}
              {location.pathname === '/notifications' && 'Notifications'}
              {location.pathname === '/messages' && 'Messages'}
              {location.pathname === '/settings' && 'Settings'}
            </h1>
          </div>
        </header>
        <div className="p-4">
          <div className="max-w-3xl mx-auto">
            {children}
          </div>
        </div>
      </main>
    </div>
  );
};

export default Layout;

// src/App.jsx
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import Layout from './components/Layout';
import Home from './pages/Home';
import Profile from './pages/Profile';
import Notifications from './pages/Notifications';
import Messages from './pages/Messages';
import Settings from './pages/Settings';
import NotFound from './pages/NotFound';

function App() {
  return (
    <Router>
      <Routes>
        <Route path="/" element={
          <Layout>
            <Home />
          </Layout>
        } />
        <Route path="/profile" element={
          <Layout>
            <Profile />
          </Layout>
        } />
        <Route path="/notifications" element={
          <Layout>
            <Notifications />
          </Layout>
        } />
        <Route path="/messages" element={
          <Layout>
            <Messages />
          </Layout>
        } />
        <Route path="/settings" element={
          <Layout>
            <Settings />
          </Layout>
        } />
        <Route path="*" element={<NotFound />} />
      </Routes>
    </Router>
  );
}

export default App;

// src/pages/Home.jsx
import React from 'react';
import PostForm from '../components/PostForm';
import PostList from '../components/PostList';

const Home = () => {
  return (
    <div className="space-y-6">
      <PostForm />
      <PostList />
    </div>
  );
};

export default Home;

// src/pages/Profile.jsx
import React from 'react';
import UserProfile from '../components/UserProfile';
import PostList from '../components/PostList';

const Profile = () => {
  return (
    <div className="space-y-6">
      <UserProfile />
      <h2 className="text-xl font-semibold mt-6 mb-4">Your Posts</h2>
      <PostList userOnly={true} />
    </div>
  );
};

export default Profile;

// src/pages/Notifications.jsx
import React from 'react';
import NotificationList from '../components/NotificationList';

const Notifications = () => {
  return (
    <div>
      <NotificationList />
    </div>
  );
};

export default Notifications;

// src/pages/Messages.jsx
import React from 'react';
import MessageList from '../components/MessageList';

const Messages = () => {
  return (
    <div>
      <MessageList />
    </div>
  );
};

export default Messages;

// src/pages/Settings.jsx
import React from 'react';
import UserSettings from '../components/UserSettings';

const Settings = () => {
  return (
    <div>
      <UserSettings />
    </div>
  );
};

export default Settings;

// src/pages/NotFound.jsx
import React from 'react';
import { Link } from 'react-router-dom';

const NotFound = () => {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="text-center">
        <h1 className="text-6xl font-bold text-gray-800">404</h1>
        <p className="text-xl mt-4 mb-8 text-gray-600">Page not found</p>
        <Link to="/" className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">
          Go back home
        </Link>
      </div>
    </div>
  );
};

export default NotFound;

// src/components/PostForm.jsx
import React, { useState } from 'react';

const PostForm = () => {
  const [content, setContent] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    // TODO: Implement post creation functionality
    console.log('Creating post:', content);
    setContent('');
  };

  return (
    <div className="bg-white p-4 rounded-lg shadow">
      <form onSubmit={handleSubmit}>
        <textarea
          className="w-full p-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          placeholder="What's happening?"
          rows="3"
          value={content}
          onChange={(e) => setContent(e.target.value)}
          required
        />
        <div className="flex justify-end mt-2">
          <button
            type="submit"
            className="px-4 py-2 bg-blue-600 text-white rounded-full hover:bg-blue-700 font-medium"
            disabled={!content.trim()}
          >
            Murmur
          </button>
        </div>
      </form>
    </div>
  );
};

export default PostForm;

// src/components/PostList.jsx
import React from 'react';
import PostItem from './PostItem';

const PostList = ({ userOnly = false }) => {
  // Mock data - would come from API in real implementation
  const posts = [
    {
      id: 1,
      content: "Just launched Murmur! Excited to see where this goes.",
      user: {
        id: 1,
        name: "John Doe",
        username: "johndoe",
        avatar: "/api/placeholder/40/40"
      },
      createdAt: "2025-03-04T10:30:00Z",
      likes: 5,
      comments: 2
    },
    {
      id: 2,
      content: "Working on a new feature for Murmur today. Stay tuned!",
      user: {
        id: 2,
        name: "Jane Smith",
        username: "janesmith",
        avatar: "/api/placeholder/40/40"
      },
      createdAt: "2025-03-04T09:15:00Z",
      likes: 10,
      comments: 3
    },
    {
      id: 3,
      content: "Just had a great brainstorming session for our next project!",
      user: {
        id: 1,
        name: "John Doe",
        username: "johndoe",
        avatar: "/api/placeholder/40/40"
      },
      createdAt: "2025-03-03T14:45:00Z",
      likes: 8,
      comments: 1
    }
  ];

  // Filter posts if userOnly is true (for profile page)
  const filteredPosts = userOnly 
    ? posts.filter(post => post.user.id === 1) // Assuming current user ID is 1
    : posts;

  return (
    <div className="space-y-4">
      {filteredPosts.length > 0 ? (
        filteredPosts.map(post => (
          <PostItem key={post.id} post={post} />
        ))
      ) : (
        <div className="bg-white p-6 rounded-lg shadow text-center">
          <p className="text-gray-500">No posts to display</p>
        </div>
      )}
    </div>
  );
};

export default PostList;

// src/components/PostItem.jsx
import React from 'react';
import { Heart, MessageCircle, Share } from 'lucide-react';
import { formatDistanceToNow } from 'date-fns';

const PostItem = ({ post }) => {
  return (
    <div className="bg-white p-4 rounded-lg shadow">
      <div className="flex items-start space-x-3">
        <img 
          src={post.user.avatar} 
          alt={post.user.name} 
          className="w-10 h-10 rounded-full"
        />
        <div className="flex-1">
          <div className="flex items-center space-x-1">
            <span className="font-semibold">{post.user.name}</span>
            <span className="text-gray-500">@{post.user.username}</span>
            <span className="text-gray-500">·</span>
            <span className="text-gray-500">
              {formatDistanceToNow(new Date(post.createdAt), { addSuffix: true })}
            </span>
          </div>
          <p className="mt-2 text-gray-900">{post.content}</p>
          <div className="flex items-center mt-4 space-x-6">
            <button className="flex items-center text-gray-500 hover:text-red-500">
              <Heart className="w-4 h-4 mr-1" />
              <span>{post.likes}</span>
            </button>
            <button className="flex items-center text-gray-500 hover:text-blue-500">
              <MessageCircle className="w-4 h-4 mr-1" />
              <span>{post.comments}</span>
            </button>
            <button className="flex items-center text-gray-500 hover:text-green-500">
              <Share className="w-4 h-4 mr-1" />
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default PostItem;

// src/components/UserProfile.jsx
import React from 'react';

const UserProfile = () => {
  // Mock user data - would come from API in real implementation
  const user = {
    id: 1,
    name: "John Doe",
    username: "johndoe",
    avatar: "/api/placeholder/80/80",
    bio: "Frontend developer and tech enthusiast. Creator of Murmur.",
    following: 125,
    followers: 438,
    joinedDate: "January 2025"
  };

  return (
    <div className="bg-white rounded-lg shadow overflow-hidden">
      <div className="bg-blue-600 h-32"></div>
      <div className="p-4">
        <div className="flex justify-between">
          <img 
            src={user.avatar} 
            alt={user.name} 
            className="w-20 h-20 rounded-full border-4 border-white -mt-12"
          />
          <button className="px-4 py-1 border border-blue-600 text-blue-600 rounded-full hover:bg-blue-50 font-medium">
            Edit Profile
          </button>
        </div>
        
        <div className="mt-2">
          <h1 className="text-xl font-bold">{user.name}</h1>
          <p className="text-gray-500">@{user.username}</p>
          
          <p className="mt-3 text-gray-700">{user.bio}</p>
          
          <p className="mt-3 text-gray-500">
            Joined {user.joinedDate}
          </p>
          
          <div className="mt-3 flex space-x-4">
            <span>
              <span className="font-bold">{user.following}</span> 
              <span className="text-gray-500"> Following</span>
            </span>
            <span>
              <span className="font-bold">{user.followers}</span> 
              <span className="text-gray-500"> Followers</span>
            </span>
          </div>
        </div>
      </div>
    </div>
  );
};

export default UserProfile;

// src/components/NotificationList.jsx
import React from 'react';

const NotificationList = () => {
  // Mock notification data - would come from API in real implementation
  const notifications = [
    {
      id: 1,
      type: 'like',
      user: {
        name: "Jane Smith",
        username: "janesmith",
        avatar: "/api/placeholder/40/40"
      },
      content: "liked your post",
      time: "15m ago"
    },
    {
      id: 2,
      type: 'follow',
      user: {
        name: "Alex Johnson",
        username: "alexj",
        avatar: "/api/placeholder/40/40"
      },
      content: "followed you",
      time: "2h ago"
    },
    {
      id: 3,
      type: 'comment',
      user: {
        name: "Sarah Williams",
        username: "sarahw",
        avatar: "/api/placeholder/40/40"
      },
      content: "commented on your post",
      time: "1d ago"
    }
  ];

  return (
    <div className="bg-white rounded-lg shadow">
      {notifications.length > 0 ? (
        <ul className="divide-y">
          {notifications.map(notification => (
            <li key={notification.id} className="p-4 hover:bg-gray-50 cursor-pointer">
              <div className="flex items-start space-x-3">
                <img 
                  src={notification.user.avatar} 
                  alt={notification.user.name} 
                  className="w-10 h-10 rounded-full"
                />
                <div>
                  <p className="text-gray-900">
                    <span className="font-medium">{notification.user.name}</span> {notification.content}
                  </p>
                  <p className="text-gray-500 text-sm">{notification.time}</p>
                </div>
              </div>
            </li>
          ))}
        </ul>
      ) : (
        <div className="p-6 text-center">
          <p className="text-gray-500">No notifications yet</p>
        </div>
      )}
    </div>
  );
};

export default NotificationList;

// src/components/MessageList.jsx
import React from 'react';

const MessageList = () => {
  // Mock conversation data - would come from API in real implementation
  const conversations = [
    {
      id: 1,
      user: {
        name: "Jane Smith",
        username: "janesmith",
        avatar: "/api/placeholder/40/40"
      },
      lastMessage: "Hey, how's it going with Murmur?",
      time: "10:30 AM",
      unread: true
    },
    {
      id: 2,
      user: {
        name: "Alex Johnson",
        username: "alexj",
        avatar: "/api/placeholder/40/40"
      },
      lastMessage: "Let's catch up soon!",
      time: "Yesterday",
      unread: false
    },
    {
      id: 3,
      user: {
        name: "Sarah Williams",
        username: "sarahw",
        avatar: "/api/placeholder/40/40"
      },
      lastMessage: "Thanks for the help with my project",
      time: "Mar 1",
      unread: false
    }
  ];

  return (
    <div className="bg-white rounded-lg shadow">
      {conversations.length > 0 ? (
        <ul className="divide-y">
          {conversations.map(conversation => (
            <li 
              key={conversation.id} 
              className={`p-4 hover:bg-gray-50 cursor-pointer flex items-start ${
                conversation.unread ? 'bg-blue-50' : ''
              }`}
            >
              <img 
                src={conversation.user.avatar} 
                alt={conversation.user.name} 
                className="w-10 h-10 rounded-full mr-3"
              />
              <div className="flex-1 min-w-0">
                <div className="flex justify-between">
                  <h3 className="font-medium truncate">{conversation.user.name}</h3>
                  <span className="text-gray-500 text-sm">{conversation.time}</span>
                </div>
                <p className={`text-sm truncate ${conversation.unread ? 'font-semibold' : 'text-gray-500'}`}>
                  {conversation.lastMessage}
                </p>
              </div>
              {conversation.unread && (
                <div className="ml-2 w-2 h-2 bg-blue-600 rounded-full"></div>
              )}
            </li>
          ))}
        </ul>
      ) : (
        <div className="p-6 text-center">
          <p className="text-gray-500">No messages yet</p>
        </div>
      )}
    </div>
  );
};

export default MessageList;

// src/components/UserSettings.jsx
import React, { useState } from 'react';

const UserSettings = () => {
  const [formData, setFormData] = useState({
    name: "John Doe",
    username: "johndoe",
    email: "john.doe@example.com",
    bio: "Frontend developer and tech enthusiast. Creator of Murmur."
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    // TODO: Implement settings update functionality
    console.log('Updating settings:', formData);
    // Mock successful update
    alert('Settings updated successfully!');
  };

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <h2 className="text-xl font-semibold mb-6">Account Settings</h2>
      
      <form onSubmit={handleSubmit}>
        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Name
            </label>
            <input
              type="text"
              name="name"
              value={formData.name}
              onChange={handleChange}
              className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              required
            />
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Username
            </label>
            <input
              type="text"
              name="username"
              value={formData.username}
              onChange={handleChange}
              className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              required
            />
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Email
            </label>
            <input
              type="email"
              name="email"
              value={formData.email}
              onChange={handleChange}
              className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              required
            />
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Bio
            </label>
            <textarea
              name="bio"
              value={formData.bio}
              onChange={handleChange}
              rows="3"
              className="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>
          
          <div className="pt-4">
            <button
              type="submit"
              className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium"
            >
              Save Changes
            </button>
          </div>
        </div>
      </form>
      
      <hr className="my-8" />
      
      <div>
        <h3 className="text-lg font-medium mb-4">Privacy</h3>
        {/* Would implement privacy settings here */}
        <p className="text-gray-500">Privacy settings will be implemented in the next phase.</p>
      </div>
      
      <hr className="my-8" />
      
      <div>
        <h3 className="text-lg font-medium mb-4 text-red-600">Danger Zone</h3>
        <button
          type="button"
          className="px-4 py-2 border border-red-600 text-red-600 rounded-lg hover:bg-red-50"
        >
          Delete Account
        </button>
      </div>
    </div>
  );
};

export default UserSettings;

